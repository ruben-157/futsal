<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FTG X9000</title>
  <style>
    :root{
      --bg:#ffffff;
      --panel:#ffffff;
      --muted:#6b7280; /* gray-500 */
      --text:#111827;  /* gray-900 */
      --accent:#2563eb; /* blue-600 */
      --accent-2:#059669; /* emerald-600 */
      --danger:#dc2626; /* red-600 */
      --warn:#b45309;   /* amber-700 */
      --border:#e5e7eb; /* gray-200 */
      --focus:#2563eb;  /* blue-600 */
    }
    /* Ensure hidden attribute truly hides on all browsers */
    [hidden]{ display:none !important }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background: radial-gradient(1200px 800px at 10% 10%, #e5f0ff 0%, #f8fafc 60%);
      color:var(--text);
      display:flex; flex-direction:column; min-height:100svh;
      overflow-x:hidden;
    }
    header{
      display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap;
      gap:12px; padding:18px 20px; border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
      backdrop-filter: blur(6px);
      position:sticky; top:0; z-index:2;
    }
    header h1{margin:0; font-size:20px; letter-spacing:.2px}
    .btn{
      appearance:none; border:1px solid #d1d5db; background:#ffffff; color:#111827;
      padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; letter-spacing:.2px;
      box-shadow: 0 1px 1px rgba(0,0,0,.04);
      min-height:44px; font-size:16px; line-height:1.2;
      touch-action: manipulation;
    }
    .btn:hover{border-color:#9ca3af; background:#f9fafb}
    .btn[disabled]{opacity:.6; cursor:not-allowed}
    .btn.primary{background:linear-gradient(180deg, #3b82f6, #2563eb); border-color:#2563eb; color:#fff}
    .btn.danger{background:linear-gradient(180deg, #ef4444, #dc2626); border-color:#b91c1c; color:#fff}
    .btn.secondary{background:#f3f4f6}

    main{padding:18px 20px; max-width:1100px; margin:0 auto; flex:1; display:flex; flex-direction:column; min-height:0}
    /* Ensure consistent top spacing across all tabs */
    main > section{ margin-top: 8px }

    /* Tabs */
    .tabs{
      position:sticky; top:62px; z-index:2; /* under header */
      display:flex; gap:8px; padding:8px 12px; border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.9));
      backdrop-filter: blur(6px);
    }
    .tab{
      flex:1; min-height:44px; padding:10px 12px; border-radius:999px; border:1px solid var(--border);
      background:#fff; color:#111827; font-weight:600; cursor:pointer;
    }
    .tab.active{ border-color:#2563eb; color:#0b3aa8; box-shadow: inset 0 0 0 1px #2563eb }
    .tab[disabled]{ opacity:.5; cursor:not-allowed }

    .picker{
      display:grid; grid-template-columns:1fr; gap:16px; align-items:start;
    }
    @media (min-width: 900px){
      .picker{grid-template-columns:1fr 1fr}
    }
    .panel{background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px}
    .panel h2{margin:0 0 8px 0; font-size:14px; color:var(--muted); font-weight:700; text-transform:uppercase}
    .counts{font-size:12px; color:var(--muted)}

    .search{
      width:100%; margin:8px 0 10px 0; padding:12px 12px; border-radius:10px; border:1px solid #d1d5db;
      background:#ffffff; color:var(--text); font-size:16px; min-height:44px;
    }
    .lists{display:flex; flex-direction:column; gap:8px; max-height:360px; overflow:auto; padding:2px; -webkit-overflow-scrolling:touch; overscroll-behavior:contain}
    .item{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:12px 14px; border:1px solid var(--border); border-radius:10px; background:#ffffff; min-height:44px}
    .item.selected{ background:#ECFDF5; border-color:#A7F3D0 }
    .item button{background:transparent; color:#6b7280; border:none; padding:6px; cursor:pointer; font-size:18px}
    .item button:hover{color:#111827}
    .item[draggable="true"]{cursor:grab}
    .item:focus-visible{outline:2px solid var(--focus); outline-offset:2px}
    .droptarget{outline:2px dashed var(--accent); outline-offset:-4px}

    .notice{margin-top:6px; color:var(--muted); font-size:12px}
    .error{color:var(--danger)}

    .actions{display:flex; gap:8px; align-items:center; justify-content:flex-end; margin:12px 0; box-sizing:border-box}

    .teams{margin-top:0}
    .teams header{display:flex; justify-content:space-between; align-items:center; gap:8px; padding:0; border:0; background:transparent; position:static}
    table{width:100%; border-collapse:collapse; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#fff}
    th, td{padding:10px 12px; border-bottom:1px solid var(--border); vertical-align:top}
    th{font-size:12px; color:var(--muted); text-transform:uppercase; text-align:left}
    tbody tr:last-child td{border-bottom:none}
    .swatch{width:16px; height:16px; border-radius:50%; display:inline-block; border:1px solid rgba(0,0,0,.15)}
    .team-name[contenteditable="true"]{padding:2px 6px; border-radius:6px}
    .team-name[contenteditable="true"]:focus{outline:2px solid var(--focus)}
    .team-pill{ display:inline-flex; align-items:center; gap:8px; padding:4px 8px; border-radius:999px; border:1px solid #e5e7eb; background:#fff; align-self:flex-start }
    .team-pill .pill-swatch{ width:14px; height:14px; border-radius:50%; border:1px solid rgba(0,0,0,.15); display:inline-block }
    .team-sub{ display:block; margin-top:4px; font-size:11px; color:var(--muted); }
    .team-pill.winner{ color:#fff; }
    .gd-pos{ color: var(--accent-2); }
    .gd-neg{ color: var(--danger); }
    /* Small badge used in All-Time table */
    .mini-pill{ display:inline-flex; align-items:center; gap:4px; padding:2px 6px; border-radius:999px; border:1px solid var(--border); background:#fff; font-size:12px; font-weight:700; color:var(--muted) }
    /* All-Time header stat cards */
    #allTimeSection .stat-cards{ display:grid; grid-template-columns:1fr; gap:8px; margin:8px 0 }
    @media(min-width: 700px){ #allTimeSection .stat-cards{ grid-template-columns:repeat(2,minmax(0,1fr)) } }
    @media(min-width: 1000px){ #allTimeSection .stat-cards{ grid-template-columns:repeat(4,minmax(0,1fr)) } }
    .stat-card{ display:flex; align-items:center; justify-content:flex-start; gap:10px; border:1px solid var(--border); background:#fff; border-radius:12px; padding:10px 12px; cursor:pointer; user-select:none; box-shadow: 0 1px 1px rgba(0,0,0,.04) }
    .stat-card:hover{ border-color:#d1d5db }
    .stat-card:focus-visible{ outline:2px solid var(--focus); outline-offset:2px }
    .stat-emoji{ font-size:18px; line-height:1; opacity:.9; filter:grayscale(20%); flex:0 0 auto }
    /* On small screens, keep emojis but shrink slightly to avoid wrapping */
    @media(max-width: 420px){ #allTimeSection .stat-emoji{ font-size:14px; opacity:.85 } }
    .stat-meta{ display:flex; flex-direction:column; min-width:0 }
    .stat-title{ font-size:12px; letter-spacing:.3px; text-transform:uppercase; color:var(--muted); font-weight:800 }
    .stat-value{ font-weight:800; font-size:16px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
    .stat-sub{ font-size:12px; color:var(--muted) }
    .delta-pos{ color: var(--accent-2) }
    .delta-neg{ color: var(--danger) }
    /* Pts/Match coloring */
    .ppm-good{ color: var(--accent-2) }
    .ppm-avg{ color: var(--warn) }
    .ppm-low{ color: var(--danger) }
    .ppm-neutral{ color: var(--muted) }
    /* Compact colored badges for values */
    .badge{ display:inline-flex; align-items:center; padding:2px 8px; border-radius:999px; font-weight:800; font-size:12px }
    .badge-good{ background: var(--accent-2); color: #fff }
    .badge-avg{ background: #facc15; color: #111827 }
    .badge-low{ background: var(--danger); color: #fff }
    .badge-neutral{ background: #e5e7eb; color: var(--muted); border: 1px solid var(--border) }
    /* Podium row tints removed */
    /* Teams: vertically center cells */
    #teamsSection table th,
    #teamsSection table td{ vertical-align: middle }

    /* Leaderboard: vertically center stats cells */
    #leaderboardSection table th,
    #leaderboardSection table td{ vertical-align: middle }

    .schedule{margin-top:0}
    .pair{padding:10px 12px; border:1px solid var(--border); border-radius:8px; background:#ffffff; margin-top:8px}
    .pair.played{ opacity:.6 }
    .match-score{ text-align:right; margin-left:auto; display:flex; align-items:center; justify-content:flex-end; gap:8px }
    /* Next match highlighting */
    .pair.next{ border-color:#2563eb; border-width:2px }
    .next-heading{ color:#2563eb; font-weight:800; letter-spacing:.2px; margin:8px 0 4px 0 }
    /* Matches: show players by default; stacked layout handled in JS */
    @media (max-width:600px){ .match-score{ flex-direction:column; gap:4px } }
    /* Breathing room under panel headers in Players tab */
    #playersSection .panel > div:first-child{ margin-bottom: 10px }

    footer{margin:24px 0; color:var(--muted); font-size:12px}

    /* Mobile optimizations */
    @media (max-width: 899px){
      header{padding:14px 12px}
      .tabs{ top:54px; padding:6px 8px }
      main{padding:14px 8px; max-width:none; width:100%; margin:0}
      .panel{padding:8px}
      .lists{max-height:40vh}
      .actions{
        position: sticky; bottom: env(safe-area-inset-bottom, 0px);
        background: linear-gradient(180deg, rgba(255,255,255,0), rgba(255,255,255,0.95));
        border-top:1px solid var(--border);
        padding:10px 8px calc(10px + env(safe-area-inset-bottom, 0px));
        margin: 0;
        width: 100%;
      }
      .actions .btn.primary{flex:1}
      .panel{border-radius:12px}
      .item{border-radius:12px}
      /* Compact steppers on mobile */
      .btn.step{ min-width:32px; min-height:32px; font-size:18px }
      .score-input{ width:48px !important; min-height:32px; font-size:16px }
      .modal .score-stepper{ gap:6px; margin:0 6px }
    }

    /* Tablet enhancements */
    @media (min-width: 768px){
      /* Global container + header/tabs spacing */
      header{ padding:18px 24px }
      .tabs{ justify-content:flex-start; padding:8px 16px }
      .tab{ flex:0 0 auto; padding:10px 16px }
      main{ padding:18px 24px; max-width:1200px; width:min(96vw, 1200px) }

      /* Players: two-column grid list */
      #playersSection .panel .lists{ display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:8px }
      #playersSection .item{ width:100% }

      /* Teams: readable fixed layout and column sizing */
      #teamsSection table{ table-layout:fixed }
      #teamsSection th:nth-child(1){ width:160px }
      #teamsSection th:nth-child(3),
      #teamsSection td:nth-child(3){ width:64px; text-align:right }
      #teamsSection th:nth-child(4),
      #teamsSection th:nth-child(5),
      #teamsSection td:nth-child(4),
      #teamsSection td:nth-child(5){ width:90px; text-align:right }
      #teamsSection td:nth-child(2){ word-break:break-word }

      /* Matches: single full-width column per match on tablet */
      #matchesSection #matchesList{ display:grid; grid-template-columns:1fr; gap:12px }
      #matchesSection #matchesList > :not(.pair){ grid-column:1 / -1 }
      #matchesSection .pair{ margin-top:0; display:grid !important; grid-template-columns:1fr auto; align-items:stretch; width:100% }
      #matchesSection .match-score{ margin-left:0 }
      #matchesSection .match-label{ display:grid !important; grid-template-columns:1fr auto 1fr; align-items:stretch; gap:12px; min-width:0 }
      #matchesSection .team-card{ border:1px solid var(--border); border-radius:12px; padding:8px; background:#fff; min-width:0 }
      #matchesSection .team-card{ border:1px solid var(--border); border-radius:12px; padding:8px; background:#fff }
      #matchesSection .vs{ align-self:center; color:var(--muted); font-weight:800; letter-spacing:.2px }

      /* Leaderboard: fixed, right-aligned numeric columns */
      #leaderboardSection table{ table-layout:fixed }
      #leaderboardSection th:nth-child(1){ width:50% }
      #leaderboardSection th:nth-child(2),
      #leaderboardSection th:nth-child(3),
      #leaderboardSection th:nth-child(4),
      #leaderboardSection th:nth-child(5),
      #leaderboardSection th:nth-child(6){ width:88px; text-align:right }
      #leaderboardSection td:nth-child(2),
      #leaderboardSection td:nth-child(3),
      #leaderboardSection td:nth-child(4),
      #leaderboardSection td:nth-child(5),
      #leaderboardSection td:nth-child(6){ text-align:right }

      /* All-Time: fixed layout, numeric columns right-aligned */
      #allTimeSection table{ table-layout:fixed }
      #allTimeSection th:nth-child(1){ width:56px; text-align:left }
      #allTimeSection th:nth-child(2){ width:50% }
      #allTimeSection th:nth-child(3),
      #allTimeSection th:nth-child(4),
      #allTimeSection th:nth-child(5){ width:100px; text-align:right }
      /* Ensure Matches header stays on one line */
      #allTimeSection th:nth-child(3){ width:150px; white-space:nowrap }
      #allTimeSection td:nth-child(1){ text-align:left }
      #allTimeSection td:nth-child(3),
      #allTimeSection td:nth-child(4),
      #allTimeSection td:nth-child(5){ text-align:right }

      /* Modals: wider and two-column fields */
      .modal{ width:min(92vw, 640px) }
      .modal .modal-fields{ grid-template-columns:1fr 1fr }
    }

    @media (max-width: 767px){
      #matchesSection .vs{ display:none }
    }

    /* Large screens: optional small bumps without changing layout paradigms */
    @media (min-width: 1200px){
      main{ max-width:1200px }
    }

    /* Modal */
    .modal-overlay[hidden], .modal[hidden]{ display:none }
    .modal-overlay{
      position: fixed; inset: 0; background: rgba(0,0,0,.35); z-index: 50;
      backdrop-filter: blur(2px);
    }
    .modal{
      position: fixed; z-index: 51; left:50%; top: 10vh; transform: translateX(-50%);
      width: min(92vw, 480px); background: #fff; border:1px solid var(--border); border-radius:12px;
      box-shadow: 0 20px 40px rgba(0,0,0,.12);
      display:flex; flex-direction:column; max-height:85vh; overflow:hidden;
    }
    .modal .modal-header{ padding:14px 16px; border-bottom:1px solid var(--border); position:sticky; top:0; background:#fff; z-index:1 }
    .modal .modal-body{ padding:14px 16px; flex:1 1 auto; overflow:auto; -webkit-overflow-scrolling:touch }
    .modal .modal-actions{ display:flex; justify-content:flex-end; gap:8px; padding:12px 16px; border-top:1px solid var(--border); position:sticky; bottom:0; background:#fff; z-index:1 }
    .modal .modal-fields{ display:grid; grid-template-columns:1fr; gap:12px }
    .modal .modal-fields label{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:0 6px }
    /* In modals, keep numeric inputs compact but text inputs full-width */
    .modal .modal-fields input[type="number"]{ width:100px }
    .modal .modal-fields input[type="text"],
    .modal .modal-fields input[type="search"]{ width:100% }
    .modal .score-row{ display:grid; grid-template-columns:1fr auto; align-items:center; gap:12px }
    .modal .score-stepper{ display:flex; align-items:center; gap:8px; margin:0 6px }
    .btn.step{ min-width:36px; min-height:36px; border-radius:10px; font-size:20px; padding:0; line-height:1; display:inline-flex; align-items:center; justify-content:center }
    .score-input{ width:56px !important; min-height:36px; text-align:center; font-size:18px; border:1px solid #d1d5db; border-radius:8px; background:#fff; color:#111827 }
    /* Big toggle switch */
    .switch{ display:flex; align-items:center; gap:10px; padding:0 6px }
    .switch input{ position:absolute; opacity:0; width:1px; height:1px; overflow:hidden }
    .switch .slider{ position:relative; width:54px; height:30px; background:#e5e7eb; border-radius:9999px; box-shadow: inset 0 0 0 1px #d1d5db; flex:0 0 auto }
    .switch .slider::after{ content:""; position:absolute; top:3px; left:3px; width:24px; height:24px; background:#fff; border-radius:50%; box-shadow: 0 1px 2px rgba(0,0,0,.2) }
    .switch input:focus-visible + .slider{ outline:2px solid var(--focus); outline-offset:2px }
    .switch input:checked + .slider{ background:#2563eb; box-shadow: inset 0 0 0 1px #2563eb }
    .switch input:checked + .slider::after{ transform: translateX(24px) }
    .switch .switch-text{ font-size:14px }
    .scorers{ margin-top:8px; display:grid; grid-template-columns:1fr; gap:12px }
    .scorer-card{ border:1px solid var(--border); border-radius:8px; padding:8px }
    .scorer-title{ font-size:12px; font-weight:700; color:var(--muted); margin-bottom:6px; text-transform:uppercase }
    .scorer-row{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin:4px 0 }
    .scorer-input{ width:44px; min-height:28px; text-align:center; font-size:14px; border:1px solid #d1d5db; border-radius:6px }
    .btn.mini-step{ min-width:28px; min-height:28px; border-radius:8px; font-size:16px; padding:0; line-height:1; display:inline-flex; align-items:center; justify-content:center }

    /* Toast & Confetti */
    .toast{
      position: fixed; left:50%; bottom: calc(16px + env(safe-area-inset-bottom, 0px)); transform: translateX(-50%);
      background: #fff; color:#111827; border:1px solid #e5e7eb; border-radius:14px; padding:12px 16px; z-index:60;
      box-shadow: 0 10px 30px rgba(0,0,0,.15); font-weight:700; display:flex; gap:10px; align-items:center;
    }
    .toast .emoji{ font-size:22px }
    .toast.winner{ font-size:22px; padding:16px 20px; border-width:2px }
    .winner-banner{ font-size:28px; font-weight:800; text-align:center; color:#111827; letter-spacing:.5px; margin:0 0 12px }
    .confetti{ position: fixed; top:-10px; width:8px; height:14px; opacity:.9; z-index:55; pointer-events:none }
    @keyframes confetti-fall{ from{ transform: translateY(-10vh) rotate(0deg)} to{ transform: translateY(110vh) rotate(360deg)} }

    /* Players tab locked state (no banner) */
    #playersSection.locked .panel{ opacity:.5; pointer-events:none }
    /* Make Players tab fill height and scroll its list nicely */
    #playersSection{ flex:1; display:flex; flex-direction:column; min-height:0 }
    #playersSection .panel{ flex:1; display:flex; flex-direction:column; min-height:0; margin-bottom:12px; padding:8px; width:100%; box-sizing:border-box }
    #playersSection .panel .lists{ flex:1; max-height:none; min-height:0; overflow:auto; padding:0; width:100%; box-sizing:border-box }
    #playersSection .item{ padding:10px 10px; width:100%; box-sizing:border-box }
    #playersSection .actions{
      position: sticky;
      bottom: env(safe-area-inset-bottom, 0px);
      /* Make the bar span the full viewport width like header/tabs */
      left: 0; right: 0; width: 100vw;
      margin-left: calc(50% - 50vw);
      margin-right: calc(50% - 50vw);
      background:linear-gradient(180deg, rgba(255,255,255,0.92), #fff);
      border-top:1px solid var(--border);
      padding:10px max(8px, env(safe-area-inset-right, 0px)) calc(14px + env(safe-area-inset-bottom, 0px)) max(8px, env(safe-area-inset-left, 0px));
      margin-top:8px;
      box-sizing:border-box;
      z-index: 3;
    }
  </style>
</head>
<body>
  <header>
    <h1>FTG X9000</h1>
    <div style="display:flex; gap:8px; align-items:center">
      <button class="btn" id="btnAllTimeHeader" type="button" aria-label="Open All-Time leaderboard">All-Time Leaderboard</button>
      <button class="btn" id="btnAllTimeRefreshHeader" type="button" hidden>Refresh</button>
    </div>
  </header>
  <nav class="tabs" role="tablist" aria-label="Futsal sections">
    <button id="tabPlayers" class="tab active" role="tab" aria-selected="true" aria-controls="playersSection">Players</button>
    <button id="tabTeams" class="tab" role="tab" aria-selected="false" aria-controls="teamsSection" disabled>Teams</button>
    <button id="tabMatches" class="tab" role="tab" aria-selected="false" aria-controls="matchesSection">Matches</button>
    <button id="tabLeaderboard" class="tab" role="tab" aria-selected="false" aria-controls="leaderboardSection">Leaderboard</button>
  </nav>
  <main>
    <section id="playersSection" class="picker" role="tabpanel" aria-labelledby="tabPlayers">
      <div id="playersTopBar" style="display:flex; justify-content:flex-end; align-items:center; margin-bottom:8px">
        <button class="btn danger" id="btnResetPlayersTop" type="button" aria-label="Reset all match data" hidden>Reset</button>
      </div>
      <div class="panel" aria-labelledby="available-title">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px">
          <h2 id="available-title">Available Players</h2>
          <button id="btnAddPlayer" class="btn" type="button" aria-label="Add New Player">Add New Player</button>
        </div>
        <div id="listNot" class="lists" role="list" aria-label="Available players list"></div>
      </div>

      <div id="limitNotice" class="notice" role="status" aria-live="polite" style="display:none">Limit reached: maximum 16 players.</div>
      <div class="actions" id="playersActions">
        <div id="genError" class="notice error" role="alert" style="margin-right:auto; display:none"></div>
        <button class="btn primary" id="btnGenerateBottom" aria-label="Generate balanced teams (bottom)" disabled>Generate Teams</button>
      </div>
    </section>

    <section class="teams" id="teamsSection" role="tabpanel" aria-labelledby="tabTeams" hidden>
      <div style="overflow:auto">
        <table aria-label="Teams table" id="teamsTable">
          <thead>
            <tr>
              <th>Team</th>
              <th>Members</th>
              <th>Size</th>
            </tr>
          </thead>
          <tbody id="teamsBody"></tbody>
        </table>
      </div>

    </section>

    <section class="schedule" id="matchesSection" role="tabpanel" aria-labelledby="tabMatches" hidden>
      <div id="matchesList"></div>
    </section>

    <section id="leaderboardSection" role="tabpanel" aria-labelledby="tabLeaderboard" hidden>
      <!-- Leaderboard content rendered by JS -->
    </section>

    <!-- All-Time Leaderboard -->
    <section id="allTimeSection" role="tabpanel" aria-labelledby="btnAllTimeHeader" hidden>
      <div id="allTimeContent" aria-live="polite"></div>
    </section>

    
  </main>

  <!-- Modal for setting match results -->
  <div id="overlay" class="modal-overlay" hidden></div>
  <div id="resultModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle" hidden>
    <div class="modal-header">
      <h3 id="modalTitle" style="margin:0; font-size:18px">Set Result</h3>
    </div>
    <div class="modal-body">
      <div id="modalMatchLabel" class="notice" style="margin-bottom:8px"></div>
      <div class="modal-fields">
        <label class="score-row">
          <span id="modalTeamAName" style="min-width:120px"></span>
          <div class="score-stepper">
            <button id="modalATeamMinus" class="btn step" type="button" aria-label="Decrease goals">−</button>
            <input id="modalTeamAScore" class="score-input" type="number" inputmode="numeric" min="0" placeholder="0" aria-label="Team A goals" />
            <button id="modalATeamPlus" class="btn step" type="button" aria-label="Increase goals">+</button>
          </div>
        </label>
        <label class="score-row">
          <span id="modalTeamBName" style="min-width:120px"></span>
          <div class="score-stepper">
            <button id="modalBTeamMinus" class="btn step" type="button" aria-label="Decrease goals">−</button>
            <input id="modalTeamBScore" class="score-input" type="number" inputmode="numeric" min="0" placeholder="0" aria-label="Team B goals" />
            <button id="modalBTeamPlus" class="btn step" type="button" aria-label="Increase goals">+</button>
          </div>
        </label>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:14px; padding-top:10px; border-top:1px solid var(--border)">
        <label class="switch">
          <input id="modalTrackScorers" type="checkbox" aria-label="Track player scorers for this match" />
          <span class="slider"></span>
          <span class="switch-text">Track player scorers for this match</span>
        </label>
        <div id="modalSaveError" class="notice error" style="display:none"></div>
      </div>
      <div id="modalScorers" class="scorers"></div>
    </div>
    <div class="modal-actions">
      <button id="modalCancel" type="button" class="btn">Cancel</button>
      <button id="modalSave" type="button" class="btn primary" disabled>Save</button>
    </div>
  </div>

  <!-- Player History Modal -->
  <div id="playerModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="playerModalTitle" hidden>
    <div class="modal-header">
      <h3 id="playerModalTitle" style="margin:0; font-size:18px">Player History</h3>
    </div>
    <div class="modal-body" id="playerModalBody">
      <!-- Filled dynamically -->
    </div>
    <div class="modal-actions">
      <button id="playerModalClose" class="btn" type="button">Close</button>
    </div>
  </div>

  <!-- Modal for adding incidental player -->
  <div id="addPlayerModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="addPlayerTitle" hidden>
    <div class="modal-header">
      <h3 id="addPlayerTitle" style="margin:0; font-size:18px">Add Player</h3>
    </div>
    <div class="modal-body">
      <div class="modal-fields">
        <label style="flex-direction:column; align-items:stretch">
          <span class="notice" style="margin:0 0 6px 0">Enter a name that is not on the roster</span>
          <input id="addPlayerName" class="search" type="text" placeholder="Full name" aria-label="Player name" />
        </label>
        <label style="display:flex; align-items:center; justify-content:space-between; gap:12px">
          <span style="font-size:14px">Skill (1–5)</span>
          <div class="score-stepper">
            <button id="addPlayerSkillMinus" class="btn mini-step" type="button" aria-label="Decrease skill">−</button>
            <input id="addPlayerSkill" class="scorer-input" type="number" inputmode="numeric" min="1" max="5" step="1" value="3" aria-label="Skill level" />
            <button id="addPlayerSkillPlus" class="btn mini-step" type="button" aria-label="Increase skill">+</button>
          </div>
        </label>
        <div id="addPlayerError" class="notice error" style="display:none"></div>
      </div>
    </div>
    <div class="modal-actions">
      <button id="addPlayerCancel" type="button" class="btn">Cancel</button>
      <button id="addPlayerSave" type="button" class="btn primary" disabled>Save</button>
    </div>
  </div>

  <!-- Modal for reset confirmation -->
  <div id="resetModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="resetTitle" hidden>
    <div class="modal-header">
      <h3 id="resetTitle" style="margin:0; font-size:18px">Reset All?</h3>
    </div>
    <div class="modal-body">
      <div class="notice" style="font-weight:600">This clears attendees, teams, results, and rounds.</div>
    </div>
    <div class="modal-actions">
      <button id="resetCancel" type="button" class="btn">Cancel</button>
      <button id="resetConfirm" type="button" class="btn danger">Reset</button>
    </div>
  </div>

  <!-- Modal for choosing team count when n = 11 -->
  <div id="teamCountModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="teamCountTitle" hidden>
    <div class="modal-header">
      <h3 id="teamCountTitle" style="margin:0; font-size:18px">Choose Team Count</h3>
    </div>
    <div class="modal-body">
      <div class="notice" style="font-weight:600; margin-bottom:8px">You have 11 players. Do you want 2 teams or 3 teams?</div>
      <div class="notice">Choose 3 teams to play 4‑4‑3.</div>
    </div>
    <div class="modal-actions">
      <button id="teamCount2" type="button" class="btn">2 Teams</button>
      <button id="teamCount3" type="button" class="btn primary">3 Teams</button>
    </div>
  </div>

  <!-- Modal: Remove Last Round Confirmation -->
  <div id="removeRoundModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="removeRoundTitle" hidden>
    <div class="modal-header">
      <h3 id="removeRoundTitle" style="margin:0; font-size:18px">Remove Round</h3>
    </div>
    <div class="modal-body">
      <div id="removeRoundInfo" class="notice" style="font-weight:600; margin-bottom:8px">Are you sure you want to remove this round?</div>
      <div class="notice">This deletes all matches and results for that round.</div>
    </div>
    <div class="modal-actions">
      <button id="removeRoundCancel" type="button" class="btn">Cancel</button>
      <button id="removeRoundConfirm" type="button" class="btn danger">Remove</button>
    </div>
  </div>

  <script>
    // ----- Data & Storage -----
    const DEFAULT_PLAYERS = [
      "Ruben","Job","Ramtin","Thijs","Emiel","Frits","Gerjan","Wout","Aklilu","Aron","Aurant","Bas","Bjorn","Danny","David","Hanno","Jefta","Lenn","Nathan","Rene","Sem","Timo","Wijnand","Willem","Amir","Ralph"
    ];

    const COLORS = [
      { name: "Green",  hex: "#10B981" },
      { name: "Blue",   hex: "#3B82F6" },
      { name: "Orange", hex: "#F59E0B" },
      { name: "Grey",   hex: "#6B7280" },
    ];

    // Skill levels (0-5). Adjust in code here when needed.
    const SKILLS = {
      Ruben: 4,
      Job: 3,
      Ramtin: 2,
      Thijs: 4,
      Emiel: 4,
      Frits: 3,
      Gerjan: 3,
      Wout: 3,
      Aklilu: 1,
      Aron: 1,
      Aurant: 2,
      Bas: 4,
      Bjorn: 4,
      Danny: 3,
      David: 3,
      Hanno: 5,
      Jefta: 3,
      Lenn: 3,
      Nathan: 3,
      Rene: 4,
      Sem: 5,
      Timo: 3,
      Wijnand: 3,
      Willem: 4,
      Amir: 4,
      Ralph: 5,
    };
    const DEFAULT_SKILL = 3; // for incidental players
    const getSkill = (name) => (typeof SKILLS[name] === 'number' ? SKILLS[name] : DEFAULT_SKILL);

    // Stamina levels (1-5). Secondary to skill; used only for tie-breaks and safe post-pass swaps.
    const STAMINA = {
      Ruben: 4,
      Job: 3,
      Ramtin: 2,
      Thijs: 4,
      Emiel: 3,
      Frits: 2,
      Gerjan: 3,
      Wout: 2,
      Aklilu: 1,
      Aron: 1,
      Aurant: 2,
      Bas: 3,
      Bjorn: 3,
      Danny: 3,
      David: 3,
      Hanno: 5,
      Jefta: 4,
      Lenn: 4,
      Nathan: 4,
      Rene: 3,
      Sem: 4,
      Timo: 2,
      Wijnand: 4,
      Willem: 4,
      Amir: 4,
      Ralph: 5,
    };
    const DEFAULT_STAMINA = 3;
    const getStamina = (name) => (typeof STAMINA[name] === 'number' ? STAMINA[name] : DEFAULT_STAMINA);

    const KEYS = {
      players: 'futsal.players',
      attendees: 'futsal.match.attendees',
      teams: 'futsal.match.teams',
      timestamp: 'futsal.match.timestamp',
      results: 'futsal.match.results',
      rounds: 'futsal.match.rounds',
      prefTrackScorers: 'futsal.pref.trackScorers',
      prevRanks: 'futsal.leaderboard.prevRanks'
    };

    const state = {
      players: [],
      attendees: [],
      teams: [],
      timestamp: null,
      results: {}, // matchId -> {a:idA, b:idB, round:1..N, ga:number|null, gb:number|null}
      rounds: 2,
      celebrated: false,
      prevRanks: {}
    };

    function loadState(){
      const p = localStorage.getItem(KEYS.players);
      if(!p){
        localStorage.setItem(KEYS.players, JSON.stringify(DEFAULT_PLAYERS));
        state.players = [...DEFAULT_PLAYERS];
      } else {
        try{ state.players = JSON.parse(p) || []; }catch{ state.players = [...DEFAULT_PLAYERS]; }
        if(!Array.isArray(state.players) || state.players.length === 0){
          state.players = [...DEFAULT_PLAYERS];
          localStorage.setItem(KEYS.players, JSON.stringify(state.players));
        }
      }

      try{ state.attendees = JSON.parse(localStorage.getItem(KEYS.attendees) || '[]'); }catch{ state.attendees = []; }
      try{ state.teams = JSON.parse(localStorage.getItem(KEYS.teams) || '[]'); }catch{ state.teams = []; }
      const ts = localStorage.getItem(KEYS.timestamp);
      state.timestamp = ts ? Number(ts) : null;
      try{ state.results = JSON.parse(localStorage.getItem(KEYS.results) || '{}'); }catch{ state.results = {}; }
      const rd = localStorage.getItem(KEYS.rounds);
      state.rounds = rd ? Math.max(1, parseInt(rd, 10) || 2) : 2;
      state.prevRanks = getPrevRanks();
    }

    function saveAttendees(){ localStorage.setItem(KEYS.attendees, JSON.stringify(state.attendees)); }
    function savePlayers(){ localStorage.setItem(KEYS.players, JSON.stringify(state.players)); }
    function saveTeams(){ localStorage.setItem(KEYS.teams, JSON.stringify(state.teams)); }
    function saveTimestamp(){ if(state.timestamp) localStorage.setItem(KEYS.timestamp, String(state.timestamp)); }
    function saveResults(){ localStorage.setItem(KEYS.results, JSON.stringify(state.results)); }
    function saveRounds(){ localStorage.setItem(KEYS.rounds, String(state.rounds)); }
    function getTrackScorersPref(){
      const v = localStorage.getItem(KEYS.prefTrackScorers);
      return v === null ? false : v === 'true';
    }
    function setTrackScorersPref(on){ localStorage.setItem(KEYS.prefTrackScorers, on ? 'true' : 'false'); }
    function getPrevRanks(){
      try{ return JSON.parse(localStorage.getItem(KEYS.prevRanks) || '{}'); }catch{ return {}; }
    }
    function savePrevRanksFromRows(rows){
      const obj = {};
      rows.forEach((r, idx)=>{ obj[r.team.id] = idx; });
      localStorage.setItem(KEYS.prevRanks, JSON.stringify(obj));
    }

    // ----- Utilities -----
    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }

    // Stable time-windowed seeding: same attendees within window -> same seed
    const STABLE_WINDOW_MS = 60 * 60 * 1000; // 1 hour
    function fnv1a32(str){
      let h = 0x811c9dc5>>>0;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h>>>0;
    }
    function computeStableSeedFromAttendees(attendees){
      const bucket = Math.floor(Date.now()/STABLE_WINDOW_MS);
      const key = attendees.slice().sort((a,b)=>a.localeCompare(b)).join('|') + '|' + bucket;
      return fnv1a32(key);
    }

    function shuffleSeeded(arr, seed){
      const rng = mulberry32(seed >>> 0);
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(rng() * (i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // Post-pass: swap players across teams to reduce skill deviation from targets
    // Targets are capacity * average skill across attendees. Deterministic and bounded.
    function balanceSkillToTargets(teams){
      if(!teams || teams.length < 2) return;
      const attendees = state.attendees || [];
      if(attendees.length === 0) return;
      const totalSkill = attendees.reduce((s,n)=> s + getSkill(n), 0);
      const avg = totalSkill / attendees.length;
      const eps = 1e-9;
      const maxPasses = 8;
      // Recompute sizes/sums each pass from current teams for clarity
      for(let pass=0; pass<maxPasses; pass++){
        const sizes = teams.map(t => (t.members||[]).length);
        const sums = teams.map(t => (t.members||[]).reduce((s,n)=> s + getSkill(n), 0));
        const targets = sizes.map(sz => sz * avg);
        let bestDelta = 0; // positive means improvement
        let bestI = -1, bestJ = -1, bestA = null, bestB = null, bestAfterI = 0, bestAfterJ = 0;
        for(let i=0;i<teams.length;i++){
          for(let j=i+1;j<teams.length;j++){
            const ti = teams[i], tj = teams[j];
            const mi = [...(ti.members||[])].sort((a,b)=> a.localeCompare(b));
            const mj = [...(tj.members||[])].sort((a,b)=> a.localeCompare(b));
            const beforeErr = Math.abs(sums[i]-targets[i]) + Math.abs(sums[j]-targets[j]);
            for(const a of mi){
              const sa = getSkill(a);
              for(const b of mj){
                const sb = getSkill(b);
                const afterI = sums[i] - sa + sb;
                const afterJ = sums[j] - sb + sa;
                const afterErr = Math.abs(afterI - targets[i]) + Math.abs(afterJ - targets[j]);
                const delta = beforeErr - afterErr;
                if(delta > bestDelta + eps || (Math.abs(delta - bestDelta) <= eps && delta > eps &&
                   // deterministic tie-break on indices and names
                   (bestI === -1 || i < bestI || (i === bestI && (j < bestJ || (j === bestJ && (a < bestA || (a === bestA && b < bestB)))))))){
                  bestDelta = delta; bestI = i; bestJ = j; bestA = a; bestB = b; bestAfterI = afterI; bestAfterJ = afterJ;
                }
              }
            }
          }
        }
        if(bestDelta > eps && bestI !== -1){
          const ti = teams[bestI], tj = teams[bestJ];
          // Apply the chosen swap
          ti.members[ti.members.indexOf(bestA)] = bestB;
          tj.members[tj.members.indexOf(bestB)] = bestA;
          // Continue to next pass (recompute sums/targets fresh)
        } else {
          break; // no improvement found
        }
      }
    }

    // Post-pass: swap equal-skill players to improve stamina distribution without changing skill totals.
    function balanceStaminaEqualSkill(teams){
      if(!teams || teams.length < 2) return;
      const eps = 1e-9;
      const maxPasses = 8;
      for(let pass=0; pass<maxPasses; pass++){
        const sizes = teams.map(t => (t.members || []).length);
        const sums = teams.map(t => (t.members || []).reduce((s,n)=> s + getStamina(n), 0));
        const avgs = sums.map((s,i)=> sizes[i] ? (s / sizes[i]) : 0);
        let bestGain = 0;
        let bestI = -1, bestJ = -1, bestA = null, bestB = null;
        let deltaI = 0, deltaJ = 0; // stamina deltas for i and j
        for(let i=0;i<teams.length;i++){
          for(let j=i+1;j<teams.length;j++){
            const ti = teams[i], tj = teams[j];
            const si = sizes[i], sj = sizes[j];
            const mi = [...(ti.members||[])].sort((a,b)=> a.localeCompare(b));
            const mj = [...(tj.members||[])].sort((a,b)=> a.localeCompare(b));
            const beforeDiff = Math.abs(avgs[i] - avgs[j]);
            for(const a of mi){
              for(const b of mj){
                if(getSkill(a) !== getSkill(b)) continue;
                const sa = getStamina(a), sb = getStamina(b);
                let gain = 0, di = 0, dj = 0;
                if(si < sj){
                  if(sb <= sa) continue; // need higher stamina to smaller team
                  const beforeSmall = avgs[i];
                  const afterSmall = (sums[i] + (sb - sa)) / si;
                  gain = afterSmall - beforeSmall;
                  di = (sb - sa); dj = (sa - sb);
                } else if (si > sj){
                  if(sa <= sb) continue;
                  const beforeSmall = avgs[j];
                  const afterSmall = (sums[j] + (sa - sb)) / sj;
                  gain = afterSmall - beforeSmall;
                  di = (sb - sa); dj = (sa - sb);
                } else {
                  // Equal sizes: reduce absolute difference in average stamina
                  const after_i = (sums[i] + (sb - sa)) / si;
                  const after_j = (sums[j] + (sa - sb)) / sj;
                  const afterDiff = Math.abs(after_i - after_j);
                  gain = beforeDiff - afterDiff;
                  di = (sb - sa); dj = (sa - sb);
                }
                if(gain > bestGain + eps || (Math.abs(gain - bestGain) <= eps && gain > eps &&
                   (bestI === -1 || i < bestI || (i === bestI && (j < bestJ || (j === bestJ && (a < bestA || (a === bestA && b < bestB)))))))){
                  bestGain = gain; bestI = i; bestJ = j; bestA = a; bestB = b; deltaI = di; deltaJ = dj;
                }
              }
            }
          }
        }
        if(bestGain > eps && bestI !== -1){
          const ti = teams[bestI], tj = teams[bestJ];
          // Apply the chosen swap
          ti.members[ti.members.indexOf(bestA)] = bestB;
          tj.members[tj.members.indexOf(bestB)] = bestA;
          // continue; recompute next pass
        } else {
          break;
        }
      }
    }

    function clampPlayLimit(){
      const over = state.attendees.length > 16;
      if(over){
        state.attendees = state.attendees.slice(0,16);
        saveAttendees();
      }
      const notice = document.getElementById('limitNotice');
      if(state.attendees.length >= 16){
        notice.style.display = '';
      } else {
        notice.style.display = 'none';
      }
    }

    // ----- Rendering -----
    function renderRoster(){
      const listNot = document.getElementById('listNot');
      listNot.innerHTML = '';

      const playSet = new Set(state.attendees);
      const allPlayers = state.players
        .slice()
        .sort((a,b)=> a.localeCompare(b, undefined, { sensitivity: 'base' }));
      const notFiltered = allPlayers;

      // Available players list (single list with selection state)
      for(const name of notFiltered){
        const selected = playSet.has(name);
        const item = createListItem(name, selected);
        listNot.appendChild(item);
      }

      const genBtn = document.getElementById('btnGenerateBottom');
      if(genBtn) genBtn.textContent = `Generate Teams (${state.attendees.length})`;

      const hasTeams = state.teams && state.teams.length>0;
      const canGen = state.attendees.length >= 8 && !hasTeams;
      document.getElementById('btnGenerateBottom').disabled = !canGen;
      const addBtn = document.getElementById('btnAddPlayer');
      if(addBtn) addBtn.disabled = !!hasTeams;
      const info = document.getElementById('genError');
      // Remove players-locked warning on Players tab
      info.textContent = '';
      info.style.display = 'none';
      const sec = document.getElementById('playersSection');
      sec.classList.toggle('locked', !!hasTeams);
    }

    function createListItem(name, isSelected){
      const div = document.createElement('div');
      div.className = 'item';
      div.setAttribute('role','listitem');
      const locked = state.teams && state.teams.length>0;
      div.setAttribute('draggable', 'false');
      div.dataset.name = name;
      div.dataset.side = isSelected ? 'playing' : 'not';

      // state icon
      const icon = document.createElement('span');
      icon.textContent = isSelected ? '✓' : '';
      icon.style.minWidth = '16px';

      const label = document.createElement('div');
      label.textContent = name;
      label.style.flex = '1';

      if(isSelected){ div.classList.add('selected'); }

      // Click anywhere on item toggles
      div.tabIndex = 0;
      const onToggle = () => {
        if(state.teams && state.teams.length>0) return; // locked
        if(state.attendees.includes(name)) { moveToNot(name); } else { moveToPlay(name); }
      };
      div.addEventListener('click', (e)=>{ onToggle(); });
      div.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); onToggle(); }
      });

      // Disable DnD for simplified UI
      div.addEventListener('dragstart', (e)=>{ e.preventDefault(); });

      div.appendChild(label);
      div.appendChild(icon);
      return div;
    }

    function setupDnD(){ /* DnD disabled in single-list selection UI */ }

    function renderTeams(){
      const section = document.getElementById('teamsSection');
      const tbody = document.getElementById('teamsBody');
      tbody.innerHTML = '';
      if(!state.teams || state.teams.length === 0){
        // No teams yet: leave table empty
        return;
      }
      for(const team of state.teams){
        const tr = document.createElement('tr');
        const tdTeam = document.createElement('td');
        const pill = document.createElement('span');
        pill.className = 'team-pill';
        pill.style.borderColor = team.color;
        const nameSpan = document.createElement('span');
        nameSpan.className = 'team-name';
        nameSpan.contentEditable = 'true';
        nameSpan.textContent = team.name;
        nameSpan.dataset.teamId = String(team.id);
        nameSpan.ariaLabel = `Edit name for ${team.name}`;
        nameSpan.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){ e.preventDefault(); nameSpan.blur(); }
        });
        nameSpan.addEventListener('blur', ()=>{
          const val = (nameSpan.textContent || '').trim();
          team.name = val || team.name; // keep previous if blank
          saveTeams();
          renderSchedule();
        });
        pill.appendChild(nameSpan);
        tdTeam.appendChild(pill);

        const tdMembers = document.createElement('td');
        tdMembers.textContent = team.members.join(', ');

        const tdSize = document.createElement('td');
        tdSize.textContent = String(team.members.length);

        tr.appendChild(tdTeam);
        tr.appendChild(tdMembers);
        tr.appendChild(tdSize);
        tbody.appendChild(tr);
      }
      renderSchedule();
    }

    function renderSchedule(){
      const schedSec = document.getElementById('matchesSection');
      const list = document.getElementById('matchesList');
      list.innerHTML = '';
      if(!state.teams || state.teams.length < 2){
        const info = document.createElement('div');
        info.className = 'notice';
        info.textContent = 'Generate teams to see the match schedule.';
        list.appendChild(info);
        return;
      }
      const stableSeed = computeStableSeedFromAttendees(state.attendees || []);
      // Build all unique pairings
      const pairings = [];
      for(let i=0;i<state.teams.length;i++){
        for(let j=i+1;j<state.teams.length;j++){
          pairings.push([state.teams[i], state.teams[j]]);
        }
      }
      const totalRounds = Math.max(1, Number(state.rounds) || 2);
      let nextMarked = false;
      // Compute a single deterministic round order and repeat it for all rounds
      const baseStreak = new Map(state.teams.map(t => [t.id, 0]));
      const baseOrdered = orderRoundPairings(pairings, baseStreak, stableSeed);
      // Try to keep the repeated order from creating 3-in-a-row across round boundaries
      function createsTriple(order){
        const ids = state.teams.map(t=>t.id);
        const streak = new Map(ids.map(id=>[id,0]));
        for(let r=0;r<totalRounds;r++){
          for(const [a,b] of order){
            for(const id of ids){
              if(id===a.id || id===b.id){ streak.set(id, (streak.get(id)||0)+1); }
              else { streak.set(id, 0); }
              if((streak.get(id)||0) >= 3) return true;
            }
          }
        }
        return false;
      }
      function rotate(arr, k){
        const n = arr.length; const out = new Array(n);
        for(let i=0;i<n;i++){ out[i] = arr[(i+k)%n]; }
        return out;
      }
      let fixedOrdered = baseOrdered;
      if(createsTriple(fixedOrdered)){
        // Try reversed order
        const rev = [...baseOrdered].reverse();
        if(!createsTriple(rev)) fixedOrdered = rev; else {
          // Try rotations
          for(let k=1;k<baseOrdered.length;k++){
            const rot = rotate(baseOrdered, k);
            if(!createsTriple(rot)){ fixedOrdered = rot; break; }
          }
        }
      }
      // Flatten schedule for kickoff fairness and next-match detection
      const flat = [];
      for(let roundIdx=0; roundIdx<totalRounds; roundIdx++){
        for(const [a,b] of fixedOrdered){
          const matchId = `${Math.min(a.id,b.id)}-${Math.max(a.id,b.id)}-r${roundIdx+1}`;
          flat.push({ a, b, roundIdx, matchId });
        }
      }

      // Compute kickoff for the next unplayed match to balance starts evenly
      const startCounts = new Map(state.teams.map(t => [t.id, 0]));
      let nextKickoffId = null;
      const rng = mulberry32((stableSeed + 0x9e3779b9) >>> 0);
      let nextIndex = -1;
      for(let i=0;i<flat.length;i++){
        const { a, b, matchId } = flat[i];
        const rec = state.results[matchId];
        const played = rec && rec.ga != null && rec.gb != null;
        if(!played && nextIndex === -1){ nextIndex = i; break; }
        // assign historical kickoff deterministically for balancing, even if not stored
        const ca = startCounts.get(a.id) || 0;
        const cb = startCounts.get(b.id) || 0;
        let starter = null;
        if(ca < cb) starter = a.id; else if(cb < ca) starter = b.id; else starter = (rng() < 0.5 ? a.id : b.id);
        startCounts.set(starter, (startCounts.get(starter) || 0) + 1);
      }
      if(nextIndex >= 0){
        const { a, b } = flat[nextIndex];
        const ca = startCounts.get(a.id) || 0;
        const cb = startCounts.get(b.id) || 0;
        if(ca < cb) nextKickoffId = a.id; else if(cb < ca) nextKickoffId = b.id; else nextKickoffId = (rng() < 0.5 ? a.id : b.id);
      }

      // Render rounds using the fixed baseOrdered sequence for each round
      let flatCursor = 0;
      for(let roundIdx=0; roundIdx<totalRounds; roundIdx++){
        // Add round heading now, followed by its matches
        const h = document.createElement('div');
        h.style.marginTop = roundIdx === 0 ? '0' : '12px';
        h.style.fontWeight = '700';
        h.style.color = 'var(--muted)';
        h.textContent = `Round ${roundIdx+1}`;
        list.appendChild(h);
        fixedOrdered.forEach(([a,b]) => {
          const matchId = `${Math.min(a.id,b.id)}-${Math.max(a.id,b.id)}-r${roundIdx+1}`;
          const rec = state.results[matchId] || null;

          const row = document.createElement('div');
          row.className = 'pair';
          row.style.display = 'flex';
          row.style.flexWrap = 'wrap';
          row.style.gap = '8px 12px';
          row.style.alignItems = 'center';

          const label = document.createElement('div');
          label.style.flex = '1 1 220px';
          label.style.display = 'flex';
          label.style.gap = '8px';
          label.style.flexWrap = 'nowrap';
          label.style.flexDirection = 'column';
          label.style.alignItems = 'flex-start';
          // On tablet, CSS overrides this to a three-column grid via .match-label
          label.classList.add('match-label');
          const teamABox = document.createElement('div');
          teamABox.style.display = 'flex';
          teamABox.style.flexDirection = 'column';
          teamABox.style.alignItems = 'flex-start';
          const pillA = document.createElement('span');
          pillA.className = 'team-pill';
          pillA.style.borderColor = a.color;
          pillA.appendChild(document.createTextNode(a.name));
          const subA = document.createElement('div');
          subA.className = 'team-sub';
          subA.textContent = (a.members || []).join(', ');
          teamABox.appendChild(pillA);
          teamABox.appendChild(subA);
          teamABox.classList.add('match-team','a','team-card');
          // Insert explicit VS on tablet layout
          const teamBBox = document.createElement('div');
          teamBBox.style.display = 'flex';
          teamBBox.style.flexDirection = 'column';
          teamBBox.style.alignItems = 'flex-start';
          const pillB = document.createElement('span');
          pillB.className = 'team-pill';
          pillB.style.borderColor = b.color;
          pillB.appendChild(document.createTextNode(b.name));
          const subB = document.createElement('div');
          subB.className = 'team-sub';
          subB.textContent = (b.members || []).join(', ');
          teamBBox.appendChild(pillB);
          teamBBox.appendChild(subB);
          teamBBox.classList.add('match-team','b','team-card');
          const vsEl = document.createElement('div');
          vsEl.className = 'vs';
          vsEl.textContent = 'vs.';
          label.appendChild(teamABox);
          label.appendChild(vsEl);
          label.appendChild(teamBBox);

          const score = document.createElement('div');
          score.className = 'match-score';
          score.style.minWidth = '90px';
          score.style.fontWeight = '600';
          const isPlayed = rec && rec.ga != null && rec.gb != null;
          score.style.color = isPlayed ? '#111827' : 'var(--muted)';
          score.textContent = '';
          if(isPlayed){ row.classList.add('played'); }
          // Insert Next match heading above the first unplayed match and emphasize the card
          if(!isPlayed && !nextMarked){
            const head = document.createElement('div');
            head.className = 'next-heading';
            head.textContent = 'Next Match';
            list.appendChild(head);
            row.classList.add('next');
            nextMarked = true;
            // Show kickoff indicator only on the first upcoming match
            if(nextKickoffId != null){
              if(nextKickoffId === a.id){
                const ball = document.createElement('span');
                ball.textContent = ' ⚽️';
                pillA.appendChild(ball);
              } else if(nextKickoffId === b.id){
                const ball = document.createElement('span');
                ball.textContent = ' ⚽️';
                pillB.appendChild(ball);
              }
            }
          }
          // Winner styling: solid team-color pill with white text
          if(isPlayed){
            if(rec.ga > rec.gb){
              pillA.classList.add('winner');
              pillA.style.background = a.color; pillA.style.borderColor = a.color; pillA.style.color = '#fff';
            } else if(rec.gb > rec.ga){
              pillB.classList.add('winner');
              pillB.style.background = b.color; pillB.style.borderColor = b.color; pillB.style.color = '#fff';
            }
          }

          // Button handling: show score as a button when played; otherwise show Set Result
          if(isPlayed){
            const scoreBtn = document.createElement('button');
            scoreBtn.type = 'button';
            scoreBtn.className = 'btn slim';
            scoreBtn.textContent = `${rec.ga} - ${rec.gb}`;
            scoreBtn.addEventListener('click', ()=> openResultModal({ matchId, a, b, round: roundIdx+1 }));
            score.appendChild(scoreBtn);
          } else {
            const setBtn = document.createElement('button');
            setBtn.type = 'button';
            setBtn.className = 'btn slim';
            setBtn.textContent = 'Set Result';
            setBtn.addEventListener('click', ()=> openResultModal({ matchId, a, b, round: roundIdx+1 }));
            score.appendChild(setBtn);
          }
          // Players are always shown; no toggle button

          row.appendChild(label);
          row.appendChild(score);
          list.appendChild(row);
          flatCursor++;
        });
      }
      // Add bottom controls: Remove round X (if >2 rounds) and Add additional round
      const addWrap = document.createElement('div');
      addWrap.style.margin = '12px 0 0 0';
      addWrap.style.display = 'flex';
      addWrap.style.justifyContent = 'flex-end';
      addWrap.style.gap = '8px';
      if(totalRounds > 2 && !roundHasResults(totalRounds)){
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button'; removeBtn.className = 'btn danger';
        removeBtn.textContent = `Remove round ${totalRounds}`;
        removeBtn.addEventListener('click', openRemoveRoundModal);
        addWrap.appendChild(removeBtn);
      }
      const addBtn = document.createElement('button');
      addBtn.type = 'button'; addBtn.className = 'btn'; addBtn.textContent = 'Add additional round';
      addBtn.addEventListener('click', addAdditionalRound);
      addWrap.appendChild(addBtn);
      list.appendChild(addWrap);
    }

    // Order pairings within a round to avoid any team playing 3 matches in a row across the schedule
    function orderRoundPairings(pairs, streakMap, seed){
      const rng = mulberry32((seed >>> 0));
      // Shuffle a copy to vary the base order deterministically
      const remaining = [...pairs].sort(() => rng() - 0.5);
      const ordered = [];
      const teamIds = state.teams.map(t => t.id);
      while(remaining.length){
        let pickIdx = -1;
        for(let i=0;i<remaining.length;i++){
          const aId = remaining[i][0].id, bId = remaining[i][1].id;
          const sa = streakMap.get(aId) || 0;
          const sb = streakMap.get(bId) || 0;
          if(sa < 2 && sb < 2){ pickIdx = i; break; }
        }
        if(pickIdx === -1){
          // Fallback: pick the first; we will still ensure not to exceed constraint by trying simple swap with previous
          pickIdx = 0;
        }
        const [a,b] = remaining.splice(pickIdx,1)[0];
        ordered.push([a,b]);
        // Update streaks: participants +1, others reset
        for(const id of teamIds){
          if(id === a.id || id === b.id){ streakMap.set(id, (streakMap.get(id)||0) + 1); }
          else { streakMap.set(id, 0); }
        }
      }
      return ordered;
    }

    function renderLeaderboard(){
      const lb = document.getElementById('leaderboardSection');
      lb.innerHTML = '';
      if(!state.teams || state.teams.length === 0){
        const info = document.createElement('div');
        info.className = 'notice';
        info.textContent = 'Generate teams to see the leaderboard.';
        lb.appendChild(info);
        return;
      }

      // Removed redundant 'Leaderboard' title for cleaner UI; tab already conveys context.

      // Compute points per team
      const byId = new Map(state.teams.map(t => [t.id, { team: t, pts: 0, played: 0, gf: 0, ga: 0 }]));
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key];
        if(!r) continue;
        const { a, b, ga, gb } = r;
        if(ga === null || gb === null || ga === undefined || gb === undefined) continue;
        const A = byId.get(a); const B = byId.get(b);
        if(!A || !B) continue;
        A.played++; B.played++;
        A.gf += ga; B.gf += gb;
        A.ga += gb; B.ga += ga;
        if(ga > gb){ A.pts += 3; }
        else if(gb > ga){ B.pts += 3; }
        else { A.pts += 1; B.pts += 1; }
      }
      const rows = Array.from(byId.values()).sort((x,y)=> y.pts - x.pts || y.gf - x.gf || x.team.name.localeCompare(y.team.name));

      const tournamentComplete = areAllMatchesScored();
      const prevRanks = getPrevRanks();
      // Winner banner if tournament complete
      if(tournamentComplete && rows.length){
        const top = rows[0];
        const win = document.createElement('div');
        win.className = 'winner-banner';
        win.textContent = `WINNER: ${top.team.name.toUpperCase()}!!`;
        lb.appendChild(win);
        if(!state.celebrated){
          celebrateWinner();
          state.celebrated = true;
        }
      }

      const wrap = document.createElement('div');
      wrap.style.overflow = 'auto';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th style="width:50%">Team</th><th>Played</th><th>Points</th><th>GS</th><th>GA</th><th>GD</th></tr>';
      const tbody = document.createElement('tbody');
      const winningTeamId = (tournamentComplete && rows.length) ? rows[0].team.id : null;
      rows.forEach((r, idx)=>{
        const tr = document.createElement('tr');
        const tdTeam = document.createElement('td');
        const pill = document.createElement('span');
        pill.className = 'team-pill';
        pill.style.borderColor = r.team.color;
        const label = document.createElement('span');
        label.textContent = r.team.name;
        pill.appendChild(label);
        tdTeam.appendChild(pill);
        // Rank change indicator (compare against previous render ranks)
        const prev = prevRanks[String(r.team.id)];
        const curr = idx;
        if(prev !== undefined && prev !== curr){
          const arrow = document.createElement('span');
          arrow.style.marginLeft = '6px';
          arrow.style.fontWeight = '700';
          arrow.style.fontSize = '14px';
          if(prev > curr){ arrow.textContent = ' ▲'; arrow.style.color = 'var(--accent-2)'; }
          else { arrow.textContent = ' ▼'; arrow.style.color = 'var(--danger)'; }
          tdTeam.appendChild(arrow);
        }
        if(winningTeamId && r.team.id === winningTeamId){
          const trophy = document.createElement('span');
          trophy.textContent = ' 🏆';
          trophy.style.marginLeft = '6px';
          tdTeam.appendChild(trophy);
        }
        const membersSmall = document.createElement('div');
        membersSmall.className = 'team-sub';
        membersSmall.textContent = r.team.members.join(', ');
        tdTeam.appendChild(membersSmall);
        const tdPlayed = document.createElement('td');
        tdPlayed.textContent = String(r.played);
        const tdPts = document.createElement('td');
        tdPts.textContent = String(r.pts);
        const tdGS = document.createElement('td');
        tdGS.textContent = String(r.gf);
        const tdGA = document.createElement('td');
        tdGA.textContent = String(r.ga || 0);
        const tdGD = document.createElement('td');
        const gd = (r.gf - (r.ga || 0));
        tdGD.textContent = String(gd);
        if(gd > 0) tdGD.classList.add('gd-pos');
        else if(gd < 0) tdGD.classList.add('gd-neg');
        tr.appendChild(tdTeam);
        tr.appendChild(tdPlayed);
        tr.appendChild(tdPts);
        tr.appendChild(tdGS);
        tr.appendChild(tdGA);
        tr.appendChild(tdGD);
        tbody.appendChild(tr);
      });
      table.appendChild(thead); table.appendChild(tbody);
      wrap.appendChild(table);
      lb.appendChild(wrap);
      // Save current ranks for next comparison
      savePrevRanksFromRows(rows);

      // Top Scorers (only players with >=1 goal), with AVG (goals per match)
      const scorerTotals = new Map();
      const playedCounts = new Map();
      const teamById = new Map(state.teams.map(t => [t.id, t]));
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key]; if(!r) continue;
        const { a, b, ga, gb, gpa, gpb } = r || {};
        if(gpa){ for(const [name, n] of Object.entries(gpa)){ if(n>0){ scorerTotals.set(name, (scorerTotals.get(name)||0)+n); } } }
        if(gpb){ for(const [name, n] of Object.entries(gpb)){ if(n>0){ scorerTotals.set(name, (scorerTotals.get(name)||0)+n); } } }
        const played = ga != null && gb != null;
        if(played){
          const teamA = teamById.get(a); const teamB = teamById.get(b);
          if(teamA){ for(const name of teamA.members){ playedCounts.set(name, (playedCounts.get(name)||0)+1); } }
          if(teamB){ for(const name of teamB.members){ playedCounts.set(name, (playedCounts.get(name)||0)+1); } }
        }
      }
      const scorers = Array.from(scorerTotals.entries())
        .filter(([_,n])=> n>0)
        .sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
      if(scorers.length){
        const sTitle = document.createElement('h3'); sTitle.textContent = 'Top Scorers'; sTitle.style.margin = '12px 0 6px 0';
        lb.appendChild(sTitle);
        const sTable = document.createElement('table');
        const sHead = document.createElement('thead'); sHead.innerHTML = '<tr><th style="width:60%">Player</th><th>Goals</th><th>GPM</th></tr>';
        const sBody = document.createElement('tbody');
        const topGoals = scorers[0][1];
        for(const [name, goals] of scorers){
          const played = playedCounts.get(name) || 0;
          const avg = played ? (goals/played) : 0;
          const tr = document.createElement('tr');
          const tdN = document.createElement('td');
          tdN.textContent = name + ((tournamentComplete && goals === topGoals) ? ' 🏆' : '');
          const tdG = document.createElement('td'); tdG.textContent = String(goals);
          const tdAvg = document.createElement('td'); tdAvg.textContent = avg.toFixed(1);
          tr.appendChild(tdN); tr.appendChild(tdG); tr.appendChild(tdAvg); sBody.appendChild(tr);
        }
        sTable.appendChild(sHead); sTable.appendChild(sBody);
        lb.appendChild(sTable);
      }

      // ----- Share controls when tournament complete -----
      if(tournamentComplete && rows.length){
        const shareWrap = document.createElement('div');
        shareWrap.style.margin = '14px 0 0 0';
        shareWrap.style.paddingTop = '10px';
        shareWrap.style.borderTop = '1px solid var(--border)';
        const btns = document.createElement('div');
        btns.style.display = 'flex';
        btns.style.gap = '8px';
        btns.style.marginTop = '8px';
        const copyBtn = document.createElement('button'); copyBtn.className='btn primary'; copyBtn.type='button'; copyBtn.textContent='Copy results';
        const emailBtn = document.createElement('button'); emailBtn.className='btn'; emailBtn.type='button'; emailBtn.textContent='Email summary';
        btns.appendChild(copyBtn);
        btns.appendChild(emailBtn);
        shareWrap.appendChild(btns);
        lb.appendChild(shareWrap);

        function doText(){ return buildShareText(); }
        copyBtn.onclick = async ()=>{
          const text = doText();
          try{
            await navigator.clipboard.writeText(text);
            showToast('Copied summary to clipboard');
          }catch{
            // no clipboard: show text in prompt as a last resort
            window.prompt('Copy the results:', text);
          }
        };
        emailBtn.onclick = ()=>{ emailSummary(); };
      }
    }

    // Build a concise summary of what is shown on the Leaderboard
    function buildShareText(){
      if(!state.teams || state.teams.length===0) return 'Futsal results';
      // Leaderboard data
      const byId = new Map(state.teams.map(t => [t.id, { team: t, pts: 0, played: 0, gf: 0, ga: 0 }]));
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key]; if(!r) continue;
        const { a, b, ga, gb } = r;
        if(ga == null || gb == null) continue;
        const A = byId.get(a); const B = byId.get(b); if(!A||!B) continue;
        A.played++; B.played++;
        A.gf += ga; B.gf += gb;
        A.ga += gb; B.ga += ga;
        if(ga > gb) A.pts += 3; else if(gb > ga) B.pts += 3; else { A.pts += 1; B.pts += 1; }
      }
      const rows = Array.from(byId.values()).sort((x,y)=> y.pts - x.pts || (y.gf - y.ga) - (x.gf - x.ga) || y.gf - x.gf || x.team.name.localeCompare(y.team.name));
      const winner = rows.length ? rows[0].team.name : 'Winner';
      const lines = [];
      lines.push(`🏆 WINNER: ${winner}`);
      lines.push('Standings:');
      rows.forEach((r, i)=>{
        const gd = r.gf - r.ga; const gdStr = gd>=0? `+${gd}`: `${gd}`;
        const members = r.team.members.join(', ');
        lines.push(`${i+1}) ${r.team.name} — ${r.pts} pts (GD ${gdStr}) • ${members}`);
      });
      // Include Top Scorers section if it is visible in the view
      const scorerTotals = new Map();
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key]; if(!r) continue;
        const { gpa, gpb } = r;
        if(gpa){ for(const [name, n] of Object.entries(gpa)){ if(n>0){ scorerTotals.set(name, (scorerTotals.get(name)||0)+n); } } }
        if(gpb){ for(const [name, n] of Object.entries(gpb)){ if(n>0){ scorerTotals.set(name, (scorerTotals.get(name)||0)+n); } } }
      }
      const scorerRows = Array.from(scorerTotals.entries()).filter(([_,n])=> n>0).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
      if(scorerRows.length){
        lines.push('Top Scorers:');
        const top = scorerRows.slice(0, 8);
        lines.push(top.map(([n,g])=> `${n} ${g}`).join(', '));
      }
      return lines.join('\n');
    }

    // CSV escaper for fields (wrap in quotes and escape quotes)
    function csvEscape(s){
      const str = String(s ?? '');
      if(/[",\n]/.test(str)) return '"' + str.replace(/"/g, '""') + '"';
      return str;
    }

    // Build per-player points summary as CSV: Date,Player,Points
    function buildEmailSummaryText(){
      const lines = [];
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth()+1).padStart(2,'0');
      const dd = String(now.getDate()).padStart(2,'0');
      const dateStr = `${yyyy}-${mm}-${dd}`;
      if(!state.teams || state.teams.length < 2){
        lines.push('Date,Player,Points');
        return lines.join('\n');
      }
      const teamById = new Map(state.teams.map(t => [t.id, t]));
      const points = new Map();
      for(const t of state.teams){ for(const name of (t.members||[])) points.set(name, 0); }
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key]; if(!r) continue;
        const { a, b, ga, gb } = r;
        if(ga == null || gb == null) continue;
        const ta = teamById.get(a); const tb = teamById.get(b); if(!ta || !tb) continue;
        if(ga > gb){ for(const n of (ta.members||[])) points.set(n, (points.get(n)||0) + 3); }
        else if(gb > ga){ for(const n of (tb.members||[])) points.set(n, (points.get(n)||0) + 3); }
        else { for(const n of (ta.members||[])) points.set(n, (points.get(n)||0) + 1); for(const n of (tb.members||[])) points.set(n, (points.get(n)||0) + 1); }
      }
      const rows = Array.from(points.entries()).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
      lines.push('Date,Player,Points');
      for(const [name, pts] of rows){ lines.push(`${dateStr},${csvEscape(name)},${pts}`); }
      return lines.join('\n');
    }

    function emailSummary(){
      const subjectDate = new Date();
      const yyyy = subjectDate.getFullYear();
      const mm = String(subjectDate.getMonth()+1).padStart(2,'0');
      const dd = String(subjectDate.getDate()).padStart(2,'0');
      const subject = `Futsal Teams & Results — ${yyyy}-${mm}-${dd}`;
      const body = buildEmailSummaryText();
      const to = 'rubenvdkamp@gmail.com';
      const mailto = `mailto:${to}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      // Open default mail client with prefilled To/Subject/Body (mobile-friendly)
      window.location.href = mailto;
    }

    function updateGenError(msg){
      const el = document.getElementById('genError');
      if(msg){ el.textContent = msg; el.style.display = ''; }
      else { el.textContent=''; el.style.display='none'; }
    }

    // ----- Modal: Set Result -----
    let modalCtx = null; // { matchId, aId, bId, round }
    function openResultModal({ matchId, a, b, round }){
      modalCtx = { matchId, aId: a.id, bId: b.id, round };
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('resultModal');
      const aName = document.getElementById('modalTeamAName');
      const bName = document.getElementById('modalTeamBName');
      const aInput = document.getElementById('modalTeamAScore');
      const bInput = document.getElementById('modalTeamBScore');
      const aMinus = document.getElementById('modalATeamMinus');
      const aPlus = document.getElementById('modalATeamPlus');
      const bMinus = document.getElementById('modalBTeamMinus');
      const bPlus = document.getElementById('modalBTeamPlus');
      const label = document.getElementById('modalMatchLabel');
      const saveBtn = document.getElementById('modalSave');

      // Render team pills in modal
      aName.textContent = '';
      bName.textContent = '';
      const pillA = document.createElement('span');
      pillA.className = 'team-pill';
      pillA.style.borderColor = a.color;
      pillA.appendChild(document.createTextNode(a.name));
      const pillB = document.createElement('span');
      pillB.className = 'team-pill';
      pillB.style.borderColor = b.color;
      pillB.appendChild(document.createTextNode(b.name));
      aName.appendChild(pillA);
      const subA = document.createElement('div');
      subA.className = 'team-sub';
      subA.textContent = (a.members || []).join(', ');
      aName.appendChild(subA);
      bName.appendChild(pillB);
      const subB = document.createElement('div');
      subB.className = 'team-sub';
      subB.textContent = (b.members || []).join(', ');
      bName.appendChild(subB);
      label.textContent = `${a.name} vs ${b.name} • Round ${round}`;

      const existing = state.results[matchId];
      aInput.value = existing && existing.ga != null ? existing.ga : '0';
      bInput.value = existing && existing.gb != null ? existing.gb : '0';

      function canSave(){ return aInput.value !== '' && bInput.value !== ''; }
      saveBtn.disabled = !canSave();
      const onInput = ()=>{ saveBtn.disabled = !canSave(); };
      aInput.oninput = onInput; bInput.oninput = onInput;

      overlay.hidden = false; modal.hidden = false;
      setTimeout(()=> aInput.focus(), 0);

      function escHandler(e){ if(e.key === 'Escape'){ closeResultModal(); } }
      document.addEventListener('keydown', escHandler, { once: true });

      document.getElementById('modalCancel').onclick = closeResultModal;
      overlay.onclick = closeResultModal;
      function step(input, delta){
        const cur = parseInt(input.value || '0', 10);
        let v = Number.isFinite(cur) ? cur : 0;
        v = Math.max(0, v + delta);
        input.value = String(v);
        onInput();
      }
      aMinus.onclick = ()=> step(aInput, -1);
      aPlus.onclick = ()=> step(aInput, +1);
      bMinus.onclick = ()=> step(bInput, -1);
      bPlus.onclick = ()=> step(bInput, +1);

      // ----- Per-player scorers -----
      const scorersWrap = document.getElementById('modalScorers');
      scorersWrap.innerHTML = '';
      const aCard = document.createElement('div'); aCard.className = 'scorer-card';
      const aTitle = document.createElement('div'); aTitle.className = 'scorer-title'; aTitle.textContent = `${a.name} scorers`;
      aCard.appendChild(aTitle);
      const bCard = document.createElement('div'); bCard.className = 'scorer-card';
      const bTitle = document.createElement('div'); bTitle.className = 'scorer-title'; bTitle.textContent = `${b.name} scorers`;
      bCard.appendChild(bTitle);
      scorersWrap.appendChild(aCard); scorersWrap.appendChild(bCard);

      const gpa = (existing && existing.gpa) ? existing.gpa : {};
      const gpb = (existing && existing.gpb) ? existing.gpb : {};
      const aInputs = new Map();
      const bInputs = new Map();
      function makeRow(name, initial, map, parent){
        const row = document.createElement('div'); row.className = 'scorer-row';
        const label = document.createElement('div'); label.textContent = name; label.style.flex='1';
        const minus = document.createElement('button'); minus.type='button'; minus.className='btn mini-step'; minus.textContent='−';
        const inp = document.createElement('input'); inp.type='number'; inp.min='0'; inp.inputMode='numeric'; inp.className='scorer-input'; inp.value = (initial ?? 0);
        const plus = document.createElement('button'); plus.type='button'; plus.className='btn mini-step'; plus.textContent='+';
        const change = (delta)=>{
          const v = Math.max(0, parseInt(inp.value||'0',10)+(delta||0));
          inp.value = String(v);
          syncIfTracking();
        };
        minus.onclick = ()=> change(-1);
        plus.onclick = ()=> change(+1);
        // independent inputs unless tracking is enabled
        inp.oninput = ()=> syncIfTracking();
        row.appendChild(label); row.appendChild(minus); row.appendChild(inp); row.appendChild(plus);
        parent.appendChild(row);
        map.set(name, inp);
      }
      for(const p of a.members){ makeRow(p, gpa[p] ?? 0, aInputs, aCard); }
      for(const p of b.members){ makeRow(p, gpb[p] ?? 0, bInputs, bCard); }

      // Toggle tracking visibility
      const trackToggle = document.getElementById('modalTrackScorers');
      const existingHasScorers = (Object.keys(gpa).length > 0 || Object.keys(gpb).length > 0);
      trackToggle.checked = existingHasScorers ? true : getTrackScorersPref();
      function sumMapVals(map){ let s=0; map.forEach((el)=>{ s += Math.max(0, parseInt(el.value||'0',10)); }); return s; }
      function updateTotalsFromPlayers(){
        const sa = sumMapVals(aInputs);
        const sb = sumMapVals(bInputs);
        const ca = Math.max(0, parseInt(aInput.value||'0',10));
        const cb = Math.max(0, parseInt(bInput.value||'0',10));
        // Only raise totals; never reduce below what user set
        const na = Math.max(ca, sa);
        const nb = Math.max(cb, sb);
        aInput.value = String(na);
        bInput.value = String(nb);
      }
      function syncIfTracking(){ if(trackToggle.checked){ updateTotalsFromPlayers(); onInput(); } }
      const applyToggle = ()=>{
        scorersWrap.style.display = trackToggle.checked ? '' : 'none';
        aInput.disabled = trackToggle.checked;
        bInput.disabled = trackToggle.checked;
        if(trackToggle.checked){ updateTotalsFromPlayers(); onInput(); }
      };
      applyToggle();
      trackToggle.onchange = ()=>{ applyToggle(); setTrackScorersPref(trackToggle.checked); };
      const saveError = document.getElementById('modalSaveError');
      saveBtn.onclick = () => {
        const ga = Math.max(0, parseInt(aInput.value, 10));
        const gb = Math.max(0, parseInt(bInput.value, 10));
        if(!Number.isFinite(ga) || !Number.isFinite(gb)) return;
        if(trackToggle.checked){
          let sa=0,sb=0; aInputs.forEach((el)=>{ sa += Math.max(0, parseInt(el.value||'0',10)); });
          bInputs.forEach((el)=>{ sb += Math.max(0, parseInt(el.value||'0',10)); });
          // Auto-raise totals if player sums surpass them; never decrease totals
          const finalA = Math.max(ga, sa);
          const finalB = Math.max(gb, sb);
          // Strict validation: if player sums are below totals, block save
          if(sa < finalA || sb < finalB){
            saveError.style.display='';
            saveError.textContent = `Distribute all goals to players: need ${finalA}-${finalB}, have ${sa}-${sb}.`;
            return;
          }
          saveError.style.display='none';
          const outA = {}; aInputs.forEach((el, name)=>{ const n = Math.max(0, parseInt(el.value||'0',10)); if(n>0) outA[name]=n; });
          const outB = {}; bInputs.forEach((el, name)=>{ const n = Math.max(0, parseInt(el.value||'0',10)); if(n>0) outB[name]=n; });
          state.results[matchId] = { a: modalCtx.aId, b: modalCtx.bId, round: modalCtx.round, ga: finalA, gb: finalB, gpa: outA, gpb: outB };
        } else {
          saveError.style.display='none';
          state.results[matchId] = { a: modalCtx.aId, b: modalCtx.bId, round: modalCtx.round, ga, gb };
        }
        saveResults();
        closeResultModal();
        // Hype toast after every saved result (streak-aware)
        try {
          showHypeToastForMatch(matchId, a, b);
        } catch(e) { /* best-effort */ }
        renderSchedule();
        renderLeaderboard();
        if(areAllMatchesScored() && !state.celebrated){
          switchTab('leaderboard');
          celebrateWinner();
          state.celebrated = true;
        }
      };
    }

    function closeResultModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('resultModal');
      overlay.hidden = true; modal.hidden = true; modalCtx = null;
    }

    // ----- Modal: Add Player -----
    function openAddPlayerModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('addPlayerModal');
      const input = document.getElementById('addPlayerName');
      const skillInput = document.getElementById('addPlayerSkill');
      const skillMinus = document.getElementById('addPlayerSkillMinus');
      const skillPlus = document.getElementById('addPlayerSkillPlus');
      const err = document.getElementById('addPlayerError');
      const save = document.getElementById('addPlayerSave');
      const cancel = document.getElementById('addPlayerCancel');

      err.style.display = 'none';
      err.textContent = '';
      input.value = '';
      skillInput.value = '3';
      save.disabled = true;

      function update(){ save.disabled = input.value.trim().length === 0; }
      input.oninput = update;
      function clampSkill(v){
        const n = Math.max(1, Math.min(5, parseInt(v||'3',10)));
        return Number.isFinite(n) ? n : 3;
      }
      skillMinus.onclick = ()=>{ skillInput.value = String(clampSkill((parseInt(skillInput.value||'3',10) - 1))); };
      skillPlus.onclick = ()=>{ skillInput.value = String(clampSkill((parseInt(skillInput.value||'3',10) + 1))); };
      skillInput.oninput = ()=>{ skillInput.value = String(clampSkill(skillInput.value)); };

      overlay.hidden = false; modal.hidden = false; setTimeout(()=> input.focus(), 0);
      overlay.onclick = closeAddPlayerModal;
      cancel.onclick = closeAddPlayerModal;
      document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ closeAddPlayerModal(); } }, { once:true });

      save.onclick = ()=>{
        const name = input.value.trim();
        if(!name){ return; }
        if(state.attendees.length >= 16){
          err.textContent = 'Cannot add more than 16 attendees.';
          err.style.display = '';
          return;
        }
        // Create a unique incidental name if it clashes with roster or attendees (case-insensitive)
        const lowerExisting = new Set([...state.players, ...state.attendees].map(x=>x.toLowerCase()));
        let finalName = name;
        if(lowerExisting.has(finalName.toLowerCase())){
          let i = 2;
          while(lowerExisting.has((name + ' ('+i+')').toLowerCase())) i++;
          finalName = name + ' ('+i+')';
        }
        // Assign provided skill for this incidental entry name (won't affect default roster player)
        SKILLS[finalName] = clampSkill(skillInput.value);
        // Default stamina for incidental player names
        if(typeof STAMINA[finalName] !== 'number') STAMINA[finalName] = DEFAULT_STAMINA;
        // Ensure the incidental player becomes part of the available roster list
        if(!state.players.some(p => p.toLowerCase() === finalName.toLowerCase())){
          state.players.push(finalName);
          savePlayers();
        }
        state.attendees.push(finalName);
        saveAttendees();
        closeAddPlayerModal();
        clampPlayLimit();
        renderRoster();
        updateTabsUI();
      };
    }
    function closeAddPlayerModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('addPlayerModal');
      overlay.hidden = true; modal.hidden = true;
    }

    // ----- Modal: Reset Confirmation -----
    function openResetModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('resetModal');
      const cancel = document.getElementById('resetCancel');
      const confirm = document.getElementById('resetConfirm');

      overlay.hidden = false; modal.hidden = false;
      overlay.onclick = closeResetModal;
      cancel.onclick = closeResetModal;
      confirm.onclick = () => { closeResetModal(); resetAll(); };
      document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ closeResetModal(); } }, { once:true });
    }
    function closeResetModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('resetModal');
      overlay.hidden = true; modal.hidden = true;
    }

    // ----- Modal: Choose team count when n=11 -----
    function openTeamCountModal(options=[2,3], nOverride){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('teamCountModal');
      const btn2 = document.getElementById('teamCount2');
      const btn3 = document.getElementById('teamCount3');
      overlay.hidden = false; modal.hidden = false;
      const body = modal.querySelector('.modal-body');
      const n = nOverride || state.attendees.length;
      const a = options[0], b = options[1];
      const sizesA = sizesDesc(n, a);
      const sizesB = sizesDesc(n, b);
      body.innerHTML = `<div class="notice" style="font-weight:600; margin-bottom:8px">You have ${n} players. Choose ${a} or ${b} teams.</div>
                        <div class="notice">${a} teams: ${sizesA} &nbsp; • &nbsp; ${b} teams: ${sizesB}</div>`;
      btn2.textContent = `${a} Teams`;
      btn3.textContent = `${b} Teams`;
      const close = ()=>{ overlay.hidden = true; modal.hidden = true; btn2.onclick = null; btn3.onclick = null; };
      overlay.onclick = close;
      document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ close(); } }, { once:true });
      btn2.onclick = ()=>{ close(); generateTeamsOverride(a); };
      btn3.onclick = ()=>{ close(); generateTeamsOverride(b); };
    }

    function generateTeamsOverride(tOverride){
      const n = state.attendees.length;
      if(!state.timestamp){ state.timestamp = Date.now(); saveTimestamp(); }
      const t = tOverride;
      const stableSeed = computeStableSeedFromAttendees(state.attendees);
      const shuffled = shuffleSeeded(state.attendees, stableSeed);
      // Average stamina across current attendees for stamina-aware tie-breaks
      const totalStaminaOv = state.attendees.reduce((s, name)=> s + getStamina(name), 0);
      const avgStaminaOv = n > 0 ? (totalStaminaOv / n) : DEFAULT_STAMINA;
      // Evenly distribute capacities for override
      const base = Array(t).fill(Math.floor(n/t));
      const r = n % t;
      for(let i=t-r; i<t; i++) if(i>=0 && i<t) base[i] += 1;
      const colors = COLORS.slice(0, Math.min(t, COLORS.length));
      const totalSkillOv = state.attendees.reduce((s, name)=> s + getSkill(name), 0);
      const avgSkillOv = totalSkillOv / n;
      const teamInfos = base.map((size, i) => ({
        cap: size,
        target: size * avgSkillOv,
        skillSum: 0,
        staminaSum: 0,
        team: { id: i+1, name: colors[i].name, color: colors[i].hex, members: [] }
      }));
      const orderIndex = new Map(shuffled.map((name, idx) => [name, idx]));
      const playersSorted = [...state.attendees].sort((a,b)=>{
        const sa = getSkill(a), sb = getSkill(b);
        if(sb !== sa) return sb - sa;
        return (orderIndex.get(a) ?? 0) - (orderIndex.get(b) ?? 0);
      });
      for(const player of playersSorted){
        const s = getSkill(player);
        const st = getStamina(player);
        let best = -1, bestDef = -Infinity;
        for(let i=0;i<teamInfos.length;i++){
          const info = teamInfos[i];
          if(info.team.members.length < info.cap){
            const def = info.target - info.skillSum;
            if(def > bestDef + 1e-9){ bestDef = def; best = i; }
            else if(Math.abs(def - bestDef) <= 1e-9 && best !== -1){
              const bi = teamInfos[best];
              // Stamina-aware tie-break: only within skill tie
              if(st >= avgStaminaOv){
                // Prefer smaller-capacity team when player's stamina is high
                if(info.cap < bi.cap) { best = i; }
                else if(info.cap === bi.cap){
                  // If capacities equal, prefer team with lower current staminaSum to even out
                  if(info.staminaSum < bi.staminaSum) best = i;
                }
              }
              // Existing deterministic tie-breakers
              const bestIdx = best; // might have changed above
              const bi2 = teamInfos[bestIdx];
              if(info.team.members.length < bi2.team.members.length) best = i;
              else if(info.team.members.length === bi2.team.members.length && info.skillSum < bi2.skillSum) best = i;
              else if(info.team.members.length === bi2.team.members.length && info.skillSum === bi2.skillSum && i < bestIdx) best = i;
            }
          }
        }
        if(best === -1) best = 0;
        const tgt = teamInfos[best];
        tgt.team.members.push(player);
        tgt.skillSum += s;
        tgt.staminaSum += st;
      }
      state.teams = teamInfos.map(x => x.team);
      // Post-pass: skill balancer then stamina smoothing (equal-skill swaps)
      try { balanceSkillToTargets(state.teams); } catch(_) { /* best-effort */ }
      try { balanceStaminaEqualSkill(state.teams); } catch(_) { /* best-effort */ }
      state.results = {};
      state.rounds = 2;
      localStorage.removeItem(KEYS.prevRanks);
      saveTeams(); saveResults(); saveRounds();
      renderTeams(); renderRoster(); renderSchedule(); renderLeaderboard();
      switchTab('teams'); updateTabsUI();
    }

    // Compute a sizes descriptor string using even distribution (e.g., 11 with 2 -> 6-5, with 3 -> 4-4-3)
    function sizesDesc(n, t){
      const base = Array(t).fill(Math.floor(n/t));
      const r = n % t;
      for(let i=t-r; i<t; i++) if(i>=0 && i<t) base[i] += 1;
      // Present in descending order for readability (e.g., 6-5, 4-4-3, 4-4-4-3)
      return base.sort((a,b)=> b-a).join('-');
    }

    // ----- Actions -----
    function moveToPlay(name){
      if(state.attendees.includes(name)) return;
      if(state.attendees.length >= 16){
        clampPlayLimit();
        return;
      }
      state.attendees.push(name);
      saveAttendees();
      // keep teams if any? Spec doesn't forbid changing attendees post teams; leave teams intact.
      clampPlayLimit();
      renderRoster();
      updateTabsUI();
    }
    function moveToNot(name){
      const idx = state.attendees.indexOf(name);
      if(idx>=0){
        state.attendees.splice(idx,1);
        saveAttendees();
        clampPlayLimit();
        renderRoster();
        updateTabsUI();
      }
    }

    function resetAll(){
      state.attendees = [];
      state.teams = [];
      state.results = {};
      state.timestamp = Date.now();
      state.rounds = 2;
      saveAttendees();
      saveTeams();
      saveResults();
      saveTimestamp();
      saveRounds();
      updateGenError('');
      closeResultModal();
      renderRoster();
      renderTeams();
      renderSchedule();
      renderLeaderboard();
      switchTab('players');
      updateTabsUI();
    }

    function addAdditionalRound(){
      if(!state.teams || state.teams.length < 2) return;
      state.rounds = Math.max(1, Number(state.rounds) || 2) + 1;
      state.celebrated = false;
      saveRounds();
      renderSchedule();
    }

    // Utility: does a given round have any recorded results?
    function roundHasResults(r){
      for(const key of Object.keys(state.results || {})){
        const rec = state.results[key];
        if(rec && Number(rec.round) === Number(r) && rec.ga != null && rec.gb != null){
          return true;
        }
      }
      return false;
    }

    // ----- Modal: Remove Last Round -----
    function openRemoveRoundModal(){
      const r = Math.max(1, Number(state.rounds) || 2);
      if(r <= 2) return; // Only removable when > 2
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('removeRoundModal');
      const title = document.getElementById('removeRoundTitle');
      const info = document.getElementById('removeRoundInfo');
      const cancel = document.getElementById('removeRoundCancel');
      const confirm = document.getElementById('removeRoundConfirm');
      const blocked = roundHasResults(r);
      title.textContent = blocked ? `Cannot remove Round ${r}` : `Remove Round ${r}?`;
      info.textContent = blocked ? `Round ${r} has recorded results and cannot be removed. You can only remove an empty round.` : `Are you sure you want to remove round ${r}?`;
      overlay.hidden = false; modal.hidden = false;
      const close = ()=>{ overlay.hidden = true; modal.hidden = true; cancel.onclick = null; confirm.onclick = null; };
      overlay.onclick = close;
      cancel.onclick = close;
      document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ close(); } }, { once:true });
      if(blocked){
        confirm.disabled = true;
      } else {
        confirm.disabled = false;
        confirm.onclick = ()=>{ removeLastRound(r); close(); };
      }
    }

    function removeLastRound(r){
      if(roundHasResults(r)){
        showToast('Cannot remove a round with results');
        return;
      }
      // Remove all results for round r, decrement rounds, save, and re-render
      const keys = Object.keys(state.results || {});
      for(const k of keys){
        const rec = state.results[k];
        if(rec && Number(rec.round) === Number(r)){
          delete state.results[k];
        }
      }
      state.rounds = Math.max(2, Number(r) - 1); // ensure rounds never drop below 2 via this action
      state.celebrated = false;
      saveResults();
      saveRounds();
      renderSchedule();
      renderLeaderboard();
    }

    // clearTeams replaced by resetAll (single reset action)

    function computeTeamCount(n){
      return Math.max(1, Math.min(4, Math.floor(n/4)));
    }

    function getPairings(){
      const pairs = [];
      if(!state.teams) return pairs;
      for(let i=0;i<state.teams.length;i++){
        for(let j=i+1;j<state.teams.length;j++){
          pairs.push([state.teams[i], state.teams[j]]);
        }
      }
      return pairs;
    }

    function areAllMatchesScored(){
      if(!state.teams || state.teams.length < 2) return false;
      const pairings = getPairings();
      const rounds = Math.max(1, Number(state.rounds) || 2);
      for(let r=1;r<=rounds;r++){
        for(const [a,b] of pairings){
          const id = `${Math.min(a.id,b.id)}-${Math.max(a.id,b.id)}-r${r}`;
          const rec = state.results[id];
          if(!rec || rec.ga == null || rec.gb == null) return false;
        }
      }
      return true;
    }

    function celebrateWinner(){
      // Compute top team like leaderboard
      const byId = new Map(state.teams.map(t => [t.id, { team: t, pts: 0, played: 0, gf: 0 }]));
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key];
        if(!r) continue;
        const { a, b, ga, gb } = r;
        if(ga == null || gb == null) continue;
        const A = byId.get(a); const B = byId.get(b);
        if(!A || !B) continue;
        A.played++; B.played++;
        A.gf += ga; B.gf += gb;
        if(ga > gb){ A.pts += 3; } else if(gb > ga){ B.pts += 3; } else { A.pts += 1; B.pts += 1; }
      }
      const rows = Array.from(byId.values()).sort((x,y)=> y.pts - x.pts || y.gf - x.gf || x.team.name.localeCompare(y.team.name));
      const winner = rows.length ? rows[0].team.name : 'Winner';
      showToast(`🎉 WINNER: ${winner.toUpperCase()}!!`, 'winner');
      launchConfetti();
    }

    function showToast(text, extraClass){
      const t = document.createElement('div');
      t.className = 'toast' + (extraClass ? (' ' + extraClass) : '');
      t.setAttribute('role','status');
      t.setAttribute('aria-live','polite');
      t.innerHTML = `<span class="emoji">🎉</span><span>${text}</span>`;
      document.body.appendChild(t);
      setTimeout(()=>{ t.remove(); }, 4000);
    }

    // Fun hype messages after each saved result
    const HYPE_MESSAGES = [
      'Team {TEAM} is on fire!',
      '{TEAM} turning up the heat!',
      '{TEAM} are flying!',
      'Unstoppable {TEAM}!',
      '{TEAM} with a statement win!',
      '{TEAM} grind it out!',
      'Clinical from {TEAM}.',
      '{TEAM} take the spoils!',
      '{TEAM} are cooking!',
      '{TEAM} bringing the smoke!',
      'Another one for {TEAM}!',
      '{TEAM} mean business!',
      '{TEAM} hit different today!',
      '{TEAM} ice cold.',
      '{TEAM} lock it in.',
      '{TEAM} with the dagger!',
      '{TEAM} seal the deal!',
      'Big dub for {TEAM}!',
      '{TEAM} with the clean finish!',
      '{TEAM} levels up!',
      'Momentum with {TEAM}!',
      '{TEAM} marches on!',
      'Vintage {TEAM}!',
    ];
    const DRAW_MESSAGES = [
      'All square — what a battle!',
      'Deadlock! Nothing between them.',
      'Honors even!',
      'Stalemate — tight one.',
      'Shared spoils!',
    ];
    // Schedule helper used by streak computation and sharing
    function getFixedOrderedPairs(){
      if(!state.teams || state.teams.length < 2) return [];
      const pairings = [];
      for(let i=0;i<state.teams.length;i++){
        for(let j=i+1;j<state.teams.length;j++){
          pairings.push([state.teams[i], state.teams[j]]);
        }
      }
      const stableSeed = computeStableSeedFromAttendees(state.attendees || []);
      const baseStreak = new Map(state.teams.map(t => [t.id, 0]));
      const baseOrdered = orderRoundPairings(pairings, baseStreak, stableSeed);
      const totalRounds = Math.max(1, Number(state.rounds) || 2);
      function createsTriple(order){
        const ids = state.teams.map(t=>t.id);
        const streak = new Map(ids.map(id=>[id,0]));
        for(let r=0;r<Math.min(totalRounds,3);r++){
          for(const [a,b] of order){
            for(const id of ids){
              if(id===a.id || id===b.id){ streak.set(id, (streak.get(id)||0)+1); }
              else { streak.set(id, 0); }
              if((streak.get(id)||0) >= 3) return true;
            }
          }
        }
        return false;
      }
      function rotate(arr, k){ const n=arr.length; const out=new Array(n); for(let i=0;i<n;i++){ out[i]=arr[(i+k)%n]; } return out; }
      let fixedOrdered = baseOrdered;
      if(createsTriple(fixedOrdered)){
        const rev = [...baseOrdered].reverse();
        if(!createsTriple(rev)) fixedOrdered = rev; else {
          for(let k=1;k<baseOrdered.length;k++){ const rot = rotate(baseOrdered, k); if(!createsTriple(rot)){ fixedOrdered = rot; break; } }
        }
      }
      return fixedOrdered;
    }

    // Compute current W/L/D streaks up to and including a specific match
    function computeStreaksUpTo(matchId){
      const streaks = new Map(); // id -> { type: 'W'|'L'|'D'|null, len: number }
      for(const t of (state.teams||[])) streaks.set(t.id, { type: null, len: 0 });
      if(!state.teams || state.teams.length<2) return streaks;
      const totalRounds = Math.max(1, Number(state.rounds) || 2);
      const fixedOrdered = getFixedOrderedPairs();
      const endOn = String(matchId);
      let done = false;
      for(let r=1; r<=totalRounds && !done; r++){
        for(const [a,b] of fixedOrdered){
          const id = `${Math.min(a.id,b.id)}-${Math.max(a.id,b.id)}-r${r}`;
          const rec = state.results[id];
          if(!rec || rec.ga==null || rec.gb==null){
            if(id === endOn){ done = true; break; }
            continue;
          }
          let aType = 'D', bType = 'D';
          if(rec.ga > rec.gb){ aType='W'; bType='L'; }
          else if(rec.gb > rec.ga){ aType='L'; bType='W'; }
          const sa = streaks.get(a.id); const sb = streaks.get(b.id);
          if(sa.type === aType){ sa.len += 1; } else { sa.type = aType; sa.len = 1; }
          if(sb.type === bType){ sb.len += 1; } else { sb.type = bType; sb.len = 1; }
          if(id === endOn){ done = true; break; }
        }
      }
      return streaks;
    }

    function showHypeToastForMatch(matchId, aTeam, bTeam){
      const rec = state.results[matchId];
      if(!rec) return;
      const { ga, gb } = rec;
      if(ga === gb){
        const msg = DRAW_MESSAGES[Math.floor(Math.random()*DRAW_MESSAGES.length)];
        showToast(msg);
        return;
      }
      const fixedOrdered = getFixedOrderedPairs(); // ensure deterministic order exists
      const streaks = computeStreaksUpTo(matchId);
      const aSt = streaks.get(aTeam.id) || { type:null, len:0 };
      const bSt = streaks.get(bTeam.id) || { type:null, len:0 };
      const winner = ga > gb ? aTeam : bTeam;
      const loser = ga > gb ? bTeam : aTeam;
      const wSt = ga > gb ? aSt : bSt;
      const lSt = ga > gb ? bSt : aSt;
      const WNAME = String(winner.name || 'Winners').toUpperCase();
      const LNAME = String(loser.name || 'Losers').toUpperCase();

      // Winner phrase
      let line = '';
      if(wSt.type === 'W' && wSt.len >= 2){
        const streakStr = (wSt.len === 2) ? 'two in a row' : (wSt.len === 3 ? 'a hat‑trick of wins' : `${wSt.len} straight`);
        const winStreakMsgs = [
          `TEAM ${WNAME} keep rolling — ${streakStr}!`,
          `TEAM ${WNAME} extend the streak: ${streakStr}!`,
          `Unbeatable! TEAM ${WNAME} now on ${streakStr}.`,
          `Momentum with TEAM ${WNAME}: ${streakStr}!`,
        ];
        line = winStreakMsgs[Math.floor(Math.random()*winStreakMsgs.length)];
      } else {
        const winMsgs = [
          `TEAM ${WNAME} take it!`,
          `Big win for TEAM ${WNAME}!`,
          `Clinical from TEAM ${WNAME}.`,
          `Statement win by TEAM ${WNAME}!`,
          `TEAM ${WNAME} seal the deal!`,
        ];
        line = winMsgs[Math.floor(Math.random()*winMsgs.length)];
      }

      // Losing phrase (if consecutive losses)
      if(lSt.type === 'L' && lSt.len >= 2){
        const losingStr = (lSt.len === 2) ? 'two on the bounce' : `${lSt.len} straight`;
        const loseMsgs = [
          ` Tough stretch for TEAM ${LNAME} — ${losingStr}.`,
          ` TEAM ${LNAME} drop ${losingStr}.`,
          ` Skid continues for TEAM ${LNAME}: ${losingStr}.`,
        ];
        line += loseMsgs[Math.floor(Math.random()*loseMsgs.length)];
      } else {
        const singleLoseMsgs = [
          ` Tough one for TEAM ${LNAME}.`,
          ` TEAM ${LNAME} will look to bounce back.`,
          ` TEAM ${LNAME} just short today.`,
        ];
        line += singleLoseMsgs[Math.floor(Math.random()*singleLoseMsgs.length)];
      }

      showToast(line);
    }

    function launchConfetti(){
      const colors = ['#EF4444','#F59E0B','#10B981','#3B82F6','#8B5CF6','#EC4899'];
      const count = 80;
      const nodes = [];
      for(let i=0;i<count;i++){
        const c = document.createElement('div');
        c.className = 'confetti';
        const left = Math.random()*100;
        const dur = 2.8 + Math.random()*1.8;
        const delay = Math.random()*0.5;
        c.style.left = left + 'vw';
        c.style.background = colors[i % colors.length];
        c.style.animation = `confetti-fall ${dur}s linear ${delay}s forwards`;
        document.body.appendChild(c);
        nodes.push(c);
      }
      setTimeout(()=> nodes.forEach(n=> n.remove()), 5000);
    }

    function generateTeams(){
      const n = state.attendees.length;
      if(n < 8){
        updateGenError('Need at least 8 attendees to generate teams.');
        return;
      }
      updateGenError('');
      if(n === 11){
        return openTeamCountModal([2,3], 11);
      }
      if(n === 15){
        return openTeamCountModal([3,4], 15);
      }
      if(!state.timestamp){ state.timestamp = Date.now(); saveTimestamp(); }

      const t = computeTeamCount(n);
      const stableSeed = computeStableSeedFromAttendees(state.attendees);
      const shuffled = shuffleSeeded(state.attendees, stableSeed);
      // Average stamina across current attendees for stamina-aware tie-breaks
      const totalStamina = state.attendees.reduce((s, name)=> s + getStamina(name), 0);
      const avgStamina = n > 0 ? (totalStamina / n) : DEFAULT_STAMINA;
      // target sizes: base 4, last r teams +1
      const base = Array(t).fill(4);
      const r = n - 4*t;
      for(let i=t-r; i<t; i++) if(i>=0 && i<t) base[i] += 1;

      const colors = COLORS.slice(0, Math.min(t, COLORS.length));
      // Build teams with capacity and targets based on average skill per slot
      const totalSkill = state.attendees.reduce((s, name)=> s + getSkill(name), 0);
      const avgSkill = totalSkill / n;
      const teamInfos = base.map((size, i) => ({
        cap: size,
        target: size * avgSkill,
        skillSum: 0,
        staminaSum: 0,
        team: {
          id: i+1,
          name: colors[i].name,
          color: colors[i].hex,
          members: []
        }
      }));

      // Assign players sorted by skill desc (tie-broken by seeded shuffle)
      // Choose the team with the greatest deficit (target - currentSum), respecting capacity
      const orderIndex = new Map(shuffled.map((name, idx) => [name, idx]));
      const playersSorted = [...state.attendees].sort((a,b)=>{
        const sa = getSkill(a), sb = getSkill(b);
        if(sb !== sa) return sb - sa; // higher skill first
        return (orderIndex.get(a) ?? 0) - (orderIndex.get(b) ?? 0); // deterministic tie-breaker
      });
      for(const player of playersSorted){
        const s = getSkill(player);
        const st = getStamina(player);
        let best = -1;
        let bestDef = -Infinity;
        for(let i=0;i<teamInfos.length;i++){
          const info = teamInfos[i];
          if(info.team.members.length < info.cap){
            const def = info.target - info.skillSum;
            if(def > bestDef + 1e-9){ bestDef = def; best = i; }
            else if(Math.abs(def - bestDef) <= 1e-9 && best !== -1){
              const bi = teamInfos[best];
              // Stamina-aware tie-break: only within skill tie
              if(st >= avgStamina){
                // Prefer smaller-capacity team when player's stamina is high
                if(info.cap < bi.cap) { best = i; }
                else if(info.cap === bi.cap){
                  // If capacities equal, prefer team with lower current staminaSum to even out
                  if(info.staminaSum < bi.staminaSum) best = i;
                }
              }
              // Existing deterministic tie-breakers
              const bestIdx = best; // may have changed above
              const bi2 = teamInfos[bestIdx];
              if(info.team.members.length < bi2.team.members.length) best = i;
              else if(info.team.members.length === bi2.team.members.length && info.skillSum < bi2.skillSum) best = i;
              else if(info.team.members.length === bi2.team.members.length && info.skillSum === bi2.skillSum && i < bestIdx) best = i;
            }
          }
        }
        if(best === -1) best = 0;
        const tgt = teamInfos[best];
        tgt.team.members.push(player);
        tgt.skillSum += s;
        tgt.staminaSum += st;
      }

      state.teams = teamInfos.map(x => x.team);
      // Post-pass: skill balancer then stamina smoothing (equal-skill swaps)
      try { balanceSkillToTargets(state.teams); } catch(_) { /* best-effort */ }
      try { balanceStaminaEqualSkill(state.teams); } catch(_) { /* best-effort */ }
      state.results = {};
      state.rounds = 2;
      saveTeams();
      saveResults();
      saveRounds();
      renderTeams();
      renderRoster();
      renderSchedule();
      renderLeaderboard();
      switchTab('teams');
      updateTabsUI();
    }

    function copyTeams(){
      if(!navigator.clipboard){ return; }
      const lines = [];
      for(const t of state.teams){
        lines.push(`${t.name}: ${t.members.join(', ')}`);
      }
      const txt = lines.join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        const btn = document.getElementById('btnCopy');
        if(btn){
          const old = btn.textContent; btn.textContent = 'Copied!';
          setTimeout(()=> btn.textContent = old, 1200);
        }
      });
    }

    // ----- Wire up -----
    document.getElementById('btnGenerateBottom').addEventListener('click', generateTeams);
    const btnResetPlayersTop = document.getElementById('btnResetPlayersTop');
    if(btnResetPlayersTop){ btnResetPlayersTop.addEventListener('click', openResetModal); }
    document.getElementById('btnAddPlayer').addEventListener('click', openAddPlayerModal);

    // Drop zones setup runs once; items are re-rendered each time
    setupDnD();

    // ----- Tabs -----
    const tabs = {
      players: document.getElementById('tabPlayers'),
      teams: document.getElementById('tabTeams'),
      matches: document.getElementById('tabMatches'),
      leaderboard: document.getElementById('tabLeaderboard'),
    };
    const panels = {
      players: document.getElementById('playersSection'),
      teams: document.getElementById('teamsSection'),
      matches: document.getElementById('matchesSection'),
      leaderboard: document.getElementById('leaderboardSection'),
      alltime: document.getElementById('allTimeSection'),
    };
    let currentTab = 'players';
    function switchTab(which){
      const hasTeams = state.teams && state.teams.length > 0;
      if((which === 'teams' || which === 'matches' || which === 'leaderboard') && !hasTeams) return; // disabled
      currentTab = which;
      for(const [k,btn] of Object.entries(tabs)){
        const active = k === which;
        btn.classList.toggle('active', active);
        btn.setAttribute('aria-selected', active ? 'true' : 'false');
      }
      for(const [k,el] of Object.entries(panels)){
        el.hidden = k !== which;
      }
      if(which === 'players'){
        renderRoster(); // ensure lock state reflected immediately
      } else if(which === 'alltime'){
        renderAllTime();
      }
      // Toggle All-Time refresh button visibility in header
      const hdrRefresh = document.getElementById('btnAllTimeRefreshHeader');
      if(hdrRefresh){ hdrRefresh.hidden = (which !== 'alltime'); }
    }
    function updateTabsUI(){
      const hasTeams = state.teams && state.teams.length > 0;
      tabs.teams.disabled = !hasTeams;
      tabs.matches.disabled = !hasTeams;
      tabs.leaderboard.disabled = !hasTeams;
      const btnResetTop = document.getElementById('btnResetPlayersTop');
      if(btnResetTop){ btnResetTop.hidden = !hasTeams; }
      if(!hasTeams && (currentTab === 'teams' || currentTab === 'matches' || currentTab === 'leaderboard')) switchTab('players');
    }
    tabs.players.addEventListener('click', ()=> switchTab('players'));
    tabs.teams.addEventListener('click', ()=> switchTab('teams'));
    tabs.matches.addEventListener('click', ()=> switchTab('matches'));
    tabs.leaderboard.addEventListener('click', ()=> switchTab('leaderboard'));
    const btnAllTimeHeader = document.getElementById('btnAllTimeHeader');
    if(btnAllTimeHeader){ btnAllTimeHeader.addEventListener('click', ()=> switchTab('alltime')); }

    // ----- All-Time Leaderboard (CSV: ecgfutsal2025-26.txt) -----
    let allTimeCache = { rows: null, ts: 0 };
    let allTimeSort = { key: 'points', dir: 'desc' }; // default: Total Points desc
    // Basis for header insight cards' rank comparisons (only changes when user selects Points or Pts/Match)
    let allTimeInsightBasis = 'points'; // 'points' | 'ppm'
    const ALLTIME_ALPHA = 5; // smoothing factor for Pts/Match thresholds
    async function renderAllTime(force=false){
      const wrap = document.getElementById('allTimeContent');
      if(!wrap) return;
      wrap.innerHTML = '';
      const loading = document.createElement('div');
      loading.className = 'notice';
      loading.textContent = 'Loading all-time stats…';
      wrap.appendChild(loading);

      try{
        const data = await loadAllTimeCSV(force);
        const stats = aggregateAllTime(data);
        sortAllTimeStats(stats);
        wrap.innerHTML = '';
        if(stats.length === 0){
          const empty = document.createElement('div');
          empty.className = 'notice';
          empty.textContent = 'No data found.';
          wrap.appendChild(empty);
        }else{
          const totalSessions = countUniqueSessions(data);
          const series = buildAllTimeSeries(data);
          const byDate = buildAllTimeByDate(data);
          window.__allTimeSeries = series; // cache for modal
          window.__allTimeByDate = byDate;
          window.__allTimeRows = data;
          const latestDate = data.map(r=>r.date).sort().slice(-1)[0];
          const preRows = data.filter(r => r.date !== latestDate);
          const preStats = aggregateAllTime(preRows);
          sortAllTimeStats(preStats);
          const preRanks = makeRankMap(preStats);
          const postRanks = makeRankMap(stats);
          // Latest sync pill (top-right) then header stat cards
          const pillBar = buildLatestSyncPill(latestDate);
          if(pillBar) wrap.appendChild(pillBar);
          const headerCards = buildAllTimeHeaderCards(preRows, data, byDate, latestDate, allTimeInsightBasis);
          if(headerCards) wrap.appendChild(headerCards);
          wrap.appendChild(buildAllTimeTable(stats, totalSessions, series, preRanks, postRanks, latestDate));
        }
        // no updated timestamp shown
      }catch(err){
        wrap.innerHTML = '';
        const msg = document.createElement('div');
        msg.className = 'notice error';
        msg.textContent = 'Failed to load all-time data. Ensure the file exists and is accessible.';
        wrap.appendChild(msg);
      }
    }

    async function loadAllTimeCSV(force=false){
      // Simple cache to avoid re-fetching on tab toggles unless forced
      if(allTimeCache.rows && !force){ return allTimeCache.rows; }
      const url = 'ecgfutsal2025-26.txt?ts=' + Date.now();
      const res = await fetch(url, { cache: 'no-store' });
      if(!res.ok){ throw new Error('HTTP ' + res.status); }
      const text = await res.text();
      const rows = parseCSVSimple(text);
      allTimeCache.rows = rows; allTimeCache.ts = Date.now();
      return rows;
    }

    function parseCSVSimple(text){
      // Handle BOM and normalize newlines
      const t = text.replace(/^\uFEFF/, '');
      const lines = t.split(/\r?\n/).map(l => l.trimEnd());
      const out = [];
      for(let i=0;i<lines.length;i++){
        const line = lines[i];
        if(!line) continue;
        if(i===0 && /^date,player,points$/i.test(line.replace(/\s+/g,''))) continue; // skip header
        const parts = line.split(',');
        if(parts.length < 3) continue;
        const date = parts[0].trim();
        const player = parts[1].trim();
        const pointsStr = parts.slice(2).join(',').trim(); // tolerate commas in names (unlikely)
        const points = Number(pointsStr);
        if(!player) continue;
        if(!Number.isFinite(points)) continue;
        out.push({ date, player, points });
      }
      return out;
    }

    function aggregateAllTime(rows){
      const map = new Map();
      for(const { player, points } of rows){
        const cur = map.get(player) || { player, matches:0, points:0 };
        cur.matches += 1;
        cur.points += points;
        map.set(player, cur);
      }
      return Array.from(map.values()).map(x => ({ ...x, ppm: x.matches ? x.points / x.matches : 0 }));
    }

    function computeAllTimeThresholds(stats, totalSessions, alpha){
      // Global mean PPM weighted by matches
      let totalPoints = 0, totalMatches = 0;
      for(const s of stats){ totalPoints += s.points; totalMatches += s.matches; }
      const mu = totalMatches > 0 ? (totalPoints / totalMatches) : 0;

      // Minimum sessions to color (lowered to show colors earlier)
      const minMatches = Math.max(2, Math.ceil((totalSessions || 0) * 0.1));
      const vals = []; const wts = [];
      for(const s of stats){
        if(s.matches >= minMatches){
          const smoothed = (s.points + alpha * mu) / (s.matches + alpha);
          vals.push(smoothed); wts.push(s.matches);
        }
      }
      let low, high;
      if(vals.length >= 5){
        // Use tertiles for clearer spread
        low = weightedPercentile(vals, wts, 1/3);
        high = weightedPercentile(vals, wts, 2/3);
      } else if(vals.length > 0){
        // Fallback around global mean
        low = Math.max(0, mu * 0.9);
        high = mu * 1.1;
        if(high - low < 0.1){ high = low + 0.1; }
      } else {
        // No eligible players
        low = 1.0; high = 2.0;
      }
      return { mu, alpha, minMatches, low, high };
    }

    function weightedPercentile(values, weights, p){
      const arr = values.map((v,i)=>({v,w:weights[i]})).sort((a,b)=> a.v - b.v);
      const totalW = arr.reduce((s,x)=> s + x.w, 0);
      if(totalW <= 0) return arr.length ? arr[0].v : 0;
      const target = p * totalW;
      let cum = 0;
      for(const x of arr){
        cum += x.w;
        if(cum >= target) return x.v;
      }
      return arr[arr.length-1]?.v ?? 0;
    }

    function countUniqueSessions(rows){
      const dates = new Set();
      for(const r of rows){ if(r && r.date) dates.add(r.date); }
      return dates.size;
    }

    function buildAllTimeSeries(rows){
      // Returns Map<Player, number[]> sorted by date ascending
      const byPlayer = new Map();
      const byDate = new Map();
      for(const r of rows){
        if(!r || !r.player || !r.date || !Number.isFinite(r.points)) continue;
        if(!byDate.has(r.date)) byDate.set(r.date, []);
        byDate.get(r.date).push({ player: r.player, points: r.points });
      }
      const dates = Array.from(byDate.keys()).sort();
      for(const d of dates){
        const entries = byDate.get(d) || [];
        for(const e of entries){
          const arr = byPlayer.get(e.player) || [];
          arr.push(e.points);
          byPlayer.set(e.player, arr);
        }
      }
      return byPlayer;
    }

    function buildAllTimeByDate(rows){
      const byDate = new Map();
      for(const r of rows){
        if(!r || !r.player || !r.date || !Number.isFinite(r.points)) continue;
        if(!byDate.has(r.date)) byDate.set(r.date, []);
        byDate.get(r.date).push({ player: r.player, points: r.points });
      }
      return byDate;
    }

    // Build the top-right latest sync pill bar
    function buildLatestSyncPill(latestDate){
      if(!latestDate) return null;
      const headerBar = document.createElement('div');
      headerBar.style.display = 'flex';
      headerBar.style.justifyContent = 'flex-end';
      headerBar.style.alignItems = 'center';
      headerBar.style.margin = '0 0 6px 0';
      // Subtle calendar icon
      const icon = document.createElementNS('http://www.w3.org/2000/svg','svg');
      icon.setAttribute('viewBox', '0 0 24 24');
      icon.setAttribute('width', '14');
      icon.setAttribute('height', '14');
      icon.setAttribute('aria-hidden', 'true');
      icon.style.marginRight = '6px';
      icon.style.flexShrink = '0';
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('x','3'); rect.setAttribute('y','5'); rect.setAttribute('width','18'); rect.setAttribute('height','16'); rect.setAttribute('rx','2');
      rect.setAttribute('fill','none'); rect.setAttribute('stroke','var(--muted)'); rect.setAttribute('stroke-width','2');
      const divider = document.createElementNS('http://www.w3.org/2000/svg','line');
      divider.setAttribute('x1','3'); divider.setAttribute('y1','9'); divider.setAttribute('x2','21'); divider.setAttribute('y2','9');
      divider.setAttribute('stroke','var(--muted)'); divider.setAttribute('stroke-width','2'); divider.setAttribute('stroke-linecap','round');
      const ringL = document.createElementNS('http://www.w3.org/2000/svg','line');
      ringL.setAttribute('x1','8'); ringL.setAttribute('y1','3'); ringL.setAttribute('x2','8'); ringL.setAttribute('y2','7');
      ringL.setAttribute('stroke','var(--muted)'); ringL.setAttribute('stroke-width','2'); ringL.setAttribute('stroke-linecap','round');
      const ringR = document.createElementNS('http://www.w3.org/2000/svg','line');
      ringR.setAttribute('x1','16'); ringR.setAttribute('y1','3'); ringR.setAttribute('x2','16'); ringR.setAttribute('y2','7');
      ringR.setAttribute('stroke','var(--muted)'); ringR.setAttribute('stroke-width','2'); ringR.setAttribute('stroke-linecap','round');
      icon.appendChild(rect); icon.appendChild(divider); icon.appendChild(ringL); icon.appendChild(ringR);

      const label = document.createElement('span');
      label.title = 'Latest session date';
      label.textContent = 'Synced with latest match: ' + formatDateLong(latestDate);
      label.style.color = 'var(--muted)';
      label.style.fontSize = '12px';
      headerBar.appendChild(icon);
      headerBar.appendChild(label);
      return headerBar;
    }

    // ----- Simple Inline Line Chart (for Player Modal) -----
    function getAllDatesAsc(){
      const byDate = window.__allTimeByDate || new Map();
      return Array.from(byDate.keys()).sort();
    }
    function getPlayerPointsAcrossDates(player){
      const byDate = window.__allTimeByDate || new Map();
      const dates = getAllDatesAsc();
      const points = dates.map(d => {
        const arr = byDate.get(d) || [];
        const hit = arr.find(e => e.player === player);
        return hit ? (Number(hit.points) || 0) : 0;
      });
      return { dates, points };
    }
    function buildLineChart(points, opts){
      const width = (opts && opts.width) || 360;
      const height = (opts && opts.height) || 140;
      const padTop = 8;
      const padRight = 10;
      const padBottom = 22; // room for x labels
      const padLeft = 34;   // room for y labels
      const stroke = (opts && opts.stroke) || 'var(--accent)';
      const strokeWidth = (opts && opts.strokeWidth) || 2;
      const dot = (opts && opts.dotRadius) || 2;
      const labels = (opts && opts.labels) || null; // optional x labels (dates)
      const n = Array.isArray(points) ? points.length : 0;
      if(!n){ return null; }
      const maxVal = Math.max(0, ...points);
      const minVal = 0; // baseline at 0
      const innerW = Math.max(1, width - padLeft - padRight);
      const innerH = Math.max(1, height - padTop - padBottom);
      const dx = n > 1 ? (innerW / (n-1)) : 0;
      const range = Math.max(1e-6, maxVal - minVal);
      function xAt(i){ return padLeft + i*dx; }
      function yAt(v){ return padTop + (1 - (v - minVal) / range) * innerH; }

      // Build path
      let d = '';
      for(let i=0;i<n;i++){
        const x = xAt(i); const y = yAt(points[i]);
        d += (i===0 ? 'M' : 'L') + x + ' ' + y + ' ';
      }
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.style.width = '100%';
      svg.style.height = 'auto';
      svg.setAttribute('role','img');
      svg.setAttribute('aria-label','Points by session');

      // Y-axis and grid ticks
      function computeYTicks(maxV){
        if(maxV <= 0) return [0, 1];
        let step = 1;
        if(maxV > 10) step = 5; else if(maxV > 4) step = 2; else step = 1;
        const out = [];
        for(let v=0; v<=maxV; v+=step){ out.push(v); }
        if(out[out.length-1] !== maxV) out.push(maxV);
        return out;
      }
      const yTicks = computeYTicks(maxVal);
      // y-axis line
      const yAxis = document.createElementNS('http://www.w3.org/2000/svg','line');
      yAxis.setAttribute('x1', String(padLeft)); yAxis.setAttribute('x2', String(padLeft));
      yAxis.setAttribute('y1', String(padTop)); yAxis.setAttribute('y2', String(padTop + innerH));
      yAxis.setAttribute('stroke', 'var(--border)'); yAxis.setAttribute('stroke-width', '1');
      svg.appendChild(yAxis);
      // grid + labels
      yTicks.forEach(v => {
        const y = yAt(v);
        const grid = document.createElementNS('http://www.w3.org/2000/svg','line');
        grid.setAttribute('x1', String(padLeft)); grid.setAttribute('x2', String(padLeft + innerW));
        grid.setAttribute('y1', String(y)); grid.setAttribute('y2', String(y));
        grid.setAttribute('stroke', 'var(--border)'); grid.setAttribute('stroke-width', '1'); grid.setAttribute('opacity', '0.7');
        svg.appendChild(grid);
        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('x', String(padLeft - 6));
        txt.setAttribute('y', String(y + 3));
        txt.setAttribute('text-anchor', 'end');
        txt.setAttribute('font-size', '10');
        txt.setAttribute('fill', 'var(--muted)');
        txt.textContent = String(v);
        svg.appendChild(txt);
      });

      // X-axis baseline
      const baseY = yAt(0);
      const xAxis = document.createElementNS('http://www.w3.org/2000/svg','line');
      xAxis.setAttribute('x1', String(padLeft)); xAxis.setAttribute('x2', String(padLeft + innerW));
      xAxis.setAttribute('y1', String(baseY)); xAxis.setAttribute('y2', String(baseY));
      xAxis.setAttribute('stroke', 'var(--border)'); xAxis.setAttribute('stroke-width', '1');
      svg.appendChild(xAxis);

      // X ticks and labels (sparse)
      if(n >= 1){
        const maxTicks = Math.min(6, n);
        const step = Math.max(1, Math.ceil((n-1) / (maxTicks-1)));
        for(let i=0;i<n;i+=step){
          const x = xAt(i);
          const tick = document.createElementNS('http://www.w3.org/2000/svg','line');
          tick.setAttribute('x1', String(x)); tick.setAttribute('x2', String(x));
          tick.setAttribute('y1', String(baseY)); tick.setAttribute('y2', String(baseY + 4));
          tick.setAttribute('stroke', 'var(--border)'); tick.setAttribute('stroke-width', '1');
          svg.appendChild(tick);
          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('x', String(x));
          label.setAttribute('y', String(baseY + 14));
          label.setAttribute('text-anchor', 'middle');
          label.setAttribute('font-size', '10');
          label.setAttribute('fill', 'var(--muted)');
          let text = String(i+1);
          if(labels && labels[i]){
            text = formatDateShort ? formatDateShort(labels[i]) : labels[i];
          }
          label.textContent = text;
          svg.appendChild(label);
        }
        // Ensure last label shows
        if((n-1) % step !== 0){
          const i = n-1; const x = xAt(i);
          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('x', String(x));
          label.setAttribute('y', String(baseY + 14));
          label.setAttribute('text-anchor', 'end');
          label.setAttribute('font-size', '10');
          label.setAttribute('fill', 'var(--muted)');
          const text = labels && labels[i] ? (formatDateShort ? formatDateShort(labels[i]) : labels[i]) : String(i+1);
          label.textContent = text;
          svg.appendChild(label);
        }
      }

      // Line path
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', d.trim());
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', stroke);
      path.setAttribute('stroke-width', String(strokeWidth));
      path.setAttribute('vector-effect', 'non-scaling-stroke');
      svg.appendChild(path);

      // Dots
      for(let i=0;i<n;i++){
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('cx', String(xAt(i))); c.setAttribute('cy', String(yAt(points[i])));
        c.setAttribute('r', String(dot));
        c.setAttribute('fill', stroke);
        c.setAttribute('opacity', '0.9');
        svg.appendChild(c);
      }
      return svg;
    }

    // Build header stat cards for All-Time page
    function buildAllTimeHeaderCards(preRows, rows, byDate, latestDate, basis){
      if(!rows || !rows.length) return null;
      const preAggArr = aggregateAllTime(preRows || []);
      const postAggArr = aggregateAllTime(rows);
      const preAgg = new Map(preAggArr.map(x => [x.player, x]));
      const postAgg = new Map(postAggArr.map(x => [x.player, x]));
      const cards = document.createElement('div');
      cards.className = 'stat-cards';

      function makeCard(title, labelText, deltaConf, sub, onClick, emoji){
        const card = document.createElement('div');
        card.className = 'stat-card';
        card.setAttribute('role', 'button');
        card.tabIndex = 0;
        if(emoji){
          const em = document.createElement('span');
          em.className = 'stat-emoji';
          em.textContent = emoji;
          em.setAttribute('aria-hidden','true');
          card.appendChild(em);
        }
        const meta = document.createElement('div'); meta.className = 'stat-meta';
        const t = document.createElement('div'); t.className = 'stat-title'; t.textContent = title;
        const v = document.createElement('div'); v.className = 'stat-value';
        if(labelText){
          const left = document.createElement('span');
          left.textContent = labelText + ' ';
          v.appendChild(left);
        }
        if(deltaConf && typeof deltaConf.value === 'number'){
          const val = deltaConf.value;
          const decimals = (typeof deltaConf.decimals === 'number') ? deltaConf.decimals : 0;
          const suffix = deltaConf.suffix || '';
          const sign = val >= 0 ? '+' : '-';
          const span = document.createElement('span');
          span.className = (val >= 0 ? 'delta-pos' : 'delta-neg');
          span.textContent = sign + Math.abs(val).toFixed(decimals) + suffix;
          v.appendChild(span);
        }
        const s = document.createElement('div'); s.className = 'stat-sub'; s.textContent = sub || '';
        meta.appendChild(t); meta.appendChild(v); meta.appendChild(s);
        card.appendChild(meta);
        if(typeof onClick === 'function'){
          card.addEventListener('click', onClick);
          card.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); onClick(); } });
        }
        return card;
      }

      // Highest climber / decliner
      let up = null; // {player, move, preRank, postRank}
      let down = null;
      // Build rank maps based on chosen basis (points or ppm), independent of table sort
      function sortByBasis(arr, key){
        const a = arr.slice();
        if(key === 'ppm'){
          a.sort((x,y)=> (y.ppm - x.ppm) || (y.points - x.points) || (y.matches - x.matches) || x.player.localeCompare(y.player));
        } else {
          a.sort((x,y)=> (y.points - x.points) || (y.ppm - x.ppm) || (y.matches - x.matches) || x.player.localeCompare(y.player));
        }
        return a;
      }
      const preOrder = sortByBasis(preAggArr, basis === 'ppm' ? 'ppm' : 'points');
      const postOrder = sortByBasis(postAggArr, basis === 'ppm' ? 'ppm' : 'points');
      const preRanks = new Map(preOrder.map((s,i)=> [s.player, i]));
      const postRanks = new Map(postOrder.map((s,i)=> [s.player, i]));
      postRanks.forEach((postIdx, player)=>{
        const preIdx = preRanks.get(player);
        if(preIdx !== undefined){
          const move = preIdx - postIdx; // positive means moved up
          if(up === null || move > up.move || (move === up.move && (postIdx < up.postRank || (postIdx === up.postRank && player < up.player)))){
            up = { player, move, preRank: preIdx, postRank: postIdx };
          }
          if(down === null || move < down.move || (move === down.move && (postIdx > down.postRank || (postIdx === down.postRank && player < down.player)))){
            down = { player, move, preRank: preIdx, postRank: postIdx };
          }
        }
      });

      // Highest PPM increase/decrease among players who played latest session (percentage change)
      const latestEntries = (byDate && latestDate) ? (byDate.get(latestDate) || []) : [];
      const playedLatest = new Set(latestEntries.map(e => e.player));
      const MIN_PRE = 3;
      function ppmDeltaCandidates(minPre){
        const arr = [];
        playedLatest.forEach(p => {
          const pre = preAgg.get(p);
          const post = postAgg.get(p);
          if(!post) return;
          const preM = pre ? pre.matches : 0;
          const prePPM = pre ? pre.ppm : 0;
          const postPPM = post.ppm;
          if(preM >= minPre && prePPM > 0){
            const delta = postPPM - prePPM;
            const pct = (delta / prePPM) * 100;
            arr.push({ player:p, delta, pct, prePPM, postPPM, preM });
          }
        });
        return arr;
      }
      let deltas = ppmDeltaCandidates(MIN_PRE);
      if(deltas.length === 0){ deltas = ppmDeltaCandidates(1); }
      let upPPM = null, downPPM = null;
      if(deltas.length){
        for(const d of deltas){
          if(upPPM === null || d.pct > upPPM.pct || (d.pct === upPPM.pct && (d.preM > upPPM.preM || (d.preM === upPPM.preM && d.player < upPPM.player)))) upPPM = d;
          if(downPPM === null || d.pct < downPPM.pct || (d.pct === downPPM.pct && (d.preM < downPPM.preM || (d.preM === downPPM.preM && d.player < downPPM.player)))) downPPM = d;
        }
      }

      // Build cards
      if(up){
        const climberCard = makeCard('Largest Rank Gain',
          up.player,
          { value: up.move, decimals: 0 },
          `${up.preRank+1} → ${up.postRank+1}`,
          ()=> openPlayerModal(up.player), '📈');
        cards.appendChild(climberCard);
      }
      if(down){
        const declinerCard = makeCard('Largest Rank Loss',
          down.player,
          { value: down.move, decimals: 0 },
          `${down.preRank+1} → ${down.postRank+1}`,
          ()=> openPlayerModal(down.player), '📉');
        cards.appendChild(declinerCard);
      }

      // Build PPM cards only when delta candidates exist; avoid confusing "No eligible" text
      if(upPPM){
        const incCard = makeCard('Largest Pts/Match Increase',
          upPPM.player,
          { value: upPPM.pct, decimals: 1, suffix: '%' },
          `${(upPPM.prePPM ?? 0).toFixed(2)} → ${(upPPM.postPPM ?? 0).toFixed(2)}`,
          ()=> openPlayerModal(upPPM.player), '➕');
        cards.appendChild(incCard);
      }
      if(downPPM){
        const decCard = makeCard('Largest Pts/Match Decrease',
          downPPM.player,
          { value: downPPM.pct, decimals: 1, suffix: '%' },
          `${(downPPM.prePPM ?? 0).toFixed(2)} → ${(downPPM.postPPM ?? 0).toFixed(2)}`,
          ()=> openPlayerModal(downPPM.player), '➖');
        cards.appendChild(decCard);
      }

      // If fewer than 4 cards (e.g., early season), still return container; grid will compress.
      return cards;
    }

    function formatDateLong(iso){
      if(!iso || typeof iso !== 'string') return iso || '';
      const parts = iso.split('-');
      if(parts.length !== 3) return iso;
      const [y, m, d] = parts;
      const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      const mi = Math.max(1, Math.min(12, parseInt(m,10))) - 1;
      const di = parseInt(d,10);
      return `${isNaN(di)?d:di} ${months[mi] || m} ${y}`;
    }
    function formatDateShort(iso){
      if(!iso || typeof iso !== 'string') return iso || '';
      const parts = iso.split('-');
      if(parts.length !== 3) return iso;
      const [y, m, d] = parts;
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const mi = Math.max(1, Math.min(12, parseInt(m,10))) - 1;
      const di = parseInt(d,10);
      return `${isNaN(di)?d:di} ${months[mi] || m}`;
    }

    function avgLastN(arr, n){
      if(!arr || arr.length === 0) return 0;
      const start = Math.max(0, arr.length - n);
      let sum = 0; let cnt = 0;
      for(let i=start;i<arr.length;i++){ sum += arr[i]; cnt++; }
      return cnt ? (sum/cnt) : 0;
    }

    function sortAllTimeStats(stats){
      const k = allTimeSort.key; const dir = allTimeSort.dir === 'asc' ? 1 : -1;
      stats.sort((a,b)=>{
        if(k === 'player') return a.player.localeCompare(b.player) * dir;
        if(k === 'matches') return (a.matches - b.matches) * dir || a.player.localeCompare(b.player);
        if(k === 'points') return (a.points - b.points) * dir || (a.ppm - b.ppm) * dir || (a.matches - b.matches) * dir || a.player.localeCompare(b.player);
        if(k === 'ppm') return ((a.ppm - b.ppm) * dir) || (a.points - b.points) * dir || (a.matches - b.matches) * dir || a.player.localeCompare(b.player);
        return 0;
      });
    }

    function makeRankMap(sortedStats){
      const map = new Map();
      for(let i=0;i<sortedStats.length;i++){
        map.set(sortedStats[i].player, i);
      }
      return map;
    }

    function buildAllTimeTable(stats, totalSessions, series, preRanks, postRanks, latestDate){
      const wrap = document.createElement('div');
      wrap.style.overflow = 'auto';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      // Rank column (not sortable)
      const thRank = document.createElement('th');
      thRank.textContent = '#';
      trHead.appendChild(thRank);
      const cols = [
        { key:'player', label:'Player', style:'width:50%' },
        { key:'matches', label:'Matches' },
        { key:'points', label:'Points' },
        { key:'ppm', label:'Pts/Match' },
      ];
      for(const col of cols){
        const th = document.createElement('th');
        if(col.style) th.setAttribute('style', col.style);
        th.textContent = col.label + (allTimeSort.key === col.key ? (allTimeSort.dir === 'asc' ? ' ▲' : ' ▼') : '');
        th.className = 'sortable';
        th.style.cursor = 'pointer';
        th.title = 'Sort by ' + col.label;
        th.addEventListener('click', ()=>{
          if(allTimeSort.key === col.key){
            allTimeSort.dir = (allTimeSort.dir === 'asc') ? 'desc' : 'asc';
          }else{
            allTimeSort.key = col.key;
            allTimeSort.dir = (col.key === 'player') ? 'asc' : 'desc';
          }
          const container = document.getElementById('allTimeContent');
          if(!allTimeCache.rows){ return; }
          const stats2 = aggregateAllTime(allTimeCache.rows);
          sortAllTimeStats(stats2);
          const totalSessions = countUniqueSessions(allTimeCache.rows);
          const series = buildAllTimeSeries(allTimeCache.rows);
          const byDate = buildAllTimeByDate(allTimeCache.rows);
          window.__allTimeSeries = series; window.__allTimeByDate = byDate; window.__allTimeRows = allTimeCache.rows;
          const latestDate = allTimeCache.rows.map(r=>r.date).sort().slice(-1)[0];
          const preRows = allTimeCache.rows.filter(r => r.date !== latestDate);
          const preStats = aggregateAllTime(preRows);
          sortAllTimeStats(preStats);
          const preRanks = makeRankMap(preStats);
          const postRanks = makeRankMap(stats2);
          // Update insight basis only when sorting by Points or Pts/Match
          if(col.key === 'points' || col.key === 'ppm'){
            allTimeInsightBasis = col.key;
          }
          container.innerHTML = '';
          const pillBar = buildLatestSyncPill(latestDate);
          if(pillBar) container.appendChild(pillBar);
          const headerCards = buildAllTimeHeaderCards(preRows, allTimeCache.rows, byDate, latestDate, allTimeInsightBasis);
          if(headerCards) container.appendChild(headerCards);
          container.appendChild(buildAllTimeTable(stats2, totalSessions, series, preRanks, postRanks, latestDate));
        });
        trHead.appendChild(th);
      }
      thead.appendChild(trHead);
      const tbody = document.createElement('tbody');
      const podiumActive = (allTimeSort && (allTimeSort.key === 'points' || allTimeSort.key === 'ppm'));
      stats.forEach((r, idx)=>{
        const tr = document.createElement('tr');
        const tdPos = document.createElement('td');
        if(podiumActive && idx === 0){ tdPos.textContent = '🥇'; }
        else if(podiumActive && idx === 1){ tdPos.textContent = '🥈'; }
        else if(podiumActive && idx === 2){ tdPos.textContent = '🥉'; }
        else { tdPos.textContent = String(idx + 1); }
        const tdN = document.createElement('td');
        tdN.textContent = r.player;
        // Trend arrow: rank movement since last session
        if(podiumActive && preRanks && postRanks){
          const pre = preRanks.get(r.player);
          const post = postRanks.get(r.player);
          if(pre !== undefined && post !== undefined){
            const move = pre - post; // positive means moved up
            if(move !== 0){
              const arrow = document.createElement('span');
              arrow.style.marginLeft = '6px';
              arrow.style.fontWeight = '700';
              arrow.style.fontSize = '14px';
              const signed = move > 0 ? `+${move}` : `${move}`;
              if(move > 0){ arrow.textContent = ` ▲ ${signed}`; arrow.style.color = 'var(--accent-2)'; }
              else { arrow.textContent = ` ▼ ${signed}`; arrow.style.color = 'var(--danger)'; }
              arrow.title = `Position: ${pre+1} → ${post+1} (${signed} since last session)`;
              tdN.appendChild(arrow);
            }
          }
        }
        const tdM = document.createElement('td');
        if(totalSessions && totalSessions > 0){
          tdM.textContent = `${r.matches}/${totalSessions}`;
        } else {
          tdM.textContent = String(r.matches);
        }
        const tdP = document.createElement('td'); tdP.textContent = String(r.points);
        const tdA = document.createElement('td');
        const ppmBadge = document.createElement('span');
        const ppm = r.ppm;
        ppmBadge.textContent = ppm.toFixed(2);
        if(ppm > 6){ ppmBadge.className = 'badge badge-good'; ppmBadge.title = 'Good: > 6 pts/match'; }
        else if(ppm >= 4){ ppmBadge.className = 'badge badge-avg'; ppmBadge.title = 'Average: 4–6 pts/match'; }
        else { ppmBadge.className = 'badge badge-low'; ppmBadge.title = 'Low: < 4 pts/match'; }
        tdA.appendChild(ppmBadge);
        tr.appendChild(tdPos); tr.appendChild(tdN); tr.appendChild(tdM); tr.appendChild(tdP); tr.appendChild(tdA);
        tr.style.cursor = 'pointer';
        tr.title = 'View player history';
        tr.addEventListener('click', ()=> openPlayerModal(r.player));
        tbody.appendChild(tr);
      });
      table.appendChild(thead); table.appendChild(tbody); wrap.appendChild(table);
      return wrap;
    }

    const btnAllTimeRefreshHeader = document.getElementById('btnAllTimeRefreshHeader');
    if(btnAllTimeRefreshHeader){ btnAllTimeRefreshHeader.addEventListener('click', ()=>{ allTimeCache.rows = null; renderAllTime(true); }); }

    // ----- Player History Modal -----
    function openPlayerModal(player){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('playerModal');
      const title = document.getElementById('playerModalTitle');
      const body = document.getElementById('playerModalBody');
      title.textContent = player;
      body.innerHTML = '';

      // Chart: points across all sessions (zeros when absent)
      try{
        const seriesAll = getPlayerPointsAcrossDates(player);
        if(seriesAll && seriesAll.points && seriesAll.points.length){
          const chartWrap = document.createElement('div');
          chartWrap.style.marginBottom = '8px';
          chartWrap.style.width = '100%';
          const svg = buildLineChart(seriesAll.points, { width: 360, height: 140, stroke: 'var(--accent)', strokeWidth: 2, dotRadius: 2, labels: seriesAll.dates });
          if(svg){ chartWrap.appendChild(svg); body.appendChild(chartWrap); }
        }
      }catch(_){ /* best-effort chart */ }

      const rows = (window.__allTimeRows || []).filter(r => r.player === player);
      // Quick stats
      const matches = rows.length;
      const totalPts = rows.reduce((s,r)=> s + r.points, 0);
      const ppm = matches ? (totalPts / matches) : 0;
      const series = (window.__allTimeSeries && window.__allTimeSeries.get(player)) || rows.map(r=> r.points);
      const last3 = avgLastN(series, 3);
      const headerStats = document.createElement('div');
      headerStats.className = 'notice';
      headerStats.style.marginBottom = '8px';
      const delta = last3 - ppm;
      const arrow = Math.abs(delta) >= 0.5 ? (delta>0 ? ' ▲' : ' ▼') : '';
      headerStats.textContent = `Matches: ${matches} • Points: ${totalPts} • Pts/Match: ${ppm.toFixed(2)}${arrow ? ` • Last 3: ${last3.toFixed(2)}${arrow}` : ''}`;
      body.appendChild(headerStats);

      // Build list per session (latest first)
      const byDate = window.__allTimeByDate || new Map();
      const dates = rows.map(r=> r.date).sort().reverse();
      for(const d of dates){
        const entries = byDate.get(d) || [];
        const sorted = entries.slice().sort((a,b)=> b.points - a.points || a.player.localeCompare(b.player));
        const idx = sorted.findIndex(e => e.player === player);
        const rank = idx>=0 ? (idx+1) : '?';
        const total = sorted.length;
        const points = rows.find(r=> r.date===d)?.points || 0;
        const max = sorted.length ? sorted[0].points : points;
        const perf = max>0 ? Math.round((points/max)*100) : 0;

        const row = document.createElement('div');
        row.style.display = 'flex'; row.style.justifyContent='space-between'; row.style.alignItems='center';
        row.style.border = '1px solid var(--border)'; row.style.borderRadius='10px'; row.style.padding='8px 10px'; row.style.margin='6px 0';

        const left = document.createElement('div');
        left.innerHTML = `<div style="font-weight:700">${formatDateLong(d)}</div>`;

        const right = document.createElement('div');
        const badge = document.createElement('span');
        badge.className = 'badge ' + (points>6 ? 'badge-good' : (points>=4 ? 'badge-avg' : 'badge-low'));
        badge.textContent = String(points);
        right.appendChild(badge);

        row.appendChild(left); row.appendChild(right);
        body.appendChild(row);
      }

      const closeBtn = document.getElementById('playerModalClose');
      const close = ()=>{ overlay.hidden = true; modal.hidden = true; closeBtn.onclick = null; overlay.onclick = null; };
      closeBtn.onclick = close;
      overlay.onclick = close;
      document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ close(); } }, { once:true });

      overlay.hidden = false; modal.hidden = false;
    }

    // ----- Init -----
    loadState();
    // Initial UI
    renderRoster();
    renderTeams();
    renderSchedule();
    renderLeaderboard();
    renderAllTime();
    clampPlayLimit();
    updateTabsUI();
    switchTab('players');
  </script>
</body>
</html>
